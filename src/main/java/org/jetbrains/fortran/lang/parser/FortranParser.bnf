{
  parserClass='org.jetbrains.fortran.lang.parser.FortranParser'
  implements='org.jetbrains.fortran.lang.psi.FortranCompositeElement'
  extends='org.jetbrains.fortran.lang.psi.impl.FortranCompositeElementImpl'
  parserUtilClass='org.jetbrains.fortran.lang.parser.FortranParserUtil'

  elementTypeHolderClass='org.jetbrains.fortran.lang.FortranTypes'
  elementTypeClass='org.jetbrains.fortran.lang.psi.FortranCompositeElementType'
  tokenTypeClass='org.jetbrains.fortran.lang.psi.FortranTokenType'

  psiClassPrefix='Fortran'
  psiImplClassSuffix='Impl'
  psiPackage='org.jetbrains.fortran.lang.psi'
  psiImplPackage='org.jetbrains.fortran.lang.psi.impl'

//  psiImplUtilClass = ''
//  psiTreeUtilClass = ''
  generateTokenAccessors=true
  tokens=[
    EQ        = '='
    EQEQ      = 'regexp:==|.eq.'
    NEQ       = 'regexp:/=|.neq.'
    COLON     = ':'
    COLONCOLON = '::'
    PLUS      = '+'
    MINUS     = '-'
    MUL       = '*'
    POWER     = '**'
    DIV       = '/'
    DIVDIV    = '//'
    LPAR      = '('
    RPAR      = ')'
    LBRACKET  = '['
    RBRACKET  = ']'
    ARRAYLBR  = '(/'
    ARRAYRBR  = '/)'
    COMMA     = ','
    DOT       = '.'
    DOLLAR    = '$'
    PERC      = '%'
    AMP       = '&'
  //  SEMICOLON = ';'
    LT        = 'regexp:<|.lt.'
    LE        = 'regexp:<=|.le.'
    GT        = 'regexp:>|.gt.'
    GE        = 'regexp:>=|.ge.'
    QUEST     = '?'

    LOGICAL_EQ  = '.eqv.'
    LOGICAL_NEQ = '.neqv.'
    AND         = '.and.'
    OR          = '.or.'
    NOT         = '.not.'

    TRUE  = '.true.'
    FALSE = '.false.'

    POINTER_ASSMNT = '=>'

    // for the external rule
    LABEL = 'LABEL'
    LABELED_DO_CONSTRUCT = 'LABELED_DO_CONSTRUCT'
    LABEL_DO_STMT = 'LABEL_DO_STMT'
    DO_TERM_ACTION_STMT = 'DO_TERM_ACTION_STMT'

  ]

  extends(".*expr")=expr
  consumeTokenMethod(".*_expr|expr")="consumeTokenFast"
}

file ::= program

// Clause 0
// System parts needed for this implementation
// format is *, label or expression, matches all possibilities
parameters_spec ::= !')' ((identifier | end | namekwd) '=')? format {
  pin = 1
  recoverWhile = parameter_spec_recover
}
private parameter_spec_recover ::= !(')' | ',')
// Clause 1 (ready)
// R101
private meta list ::= <<param>> ( ',' <<param>> )*
// R102 and R103 are trivial

// Clause 2
// R201
private program ::= (eol | program_unit)*
// R202
private program_unit ::= !<<eof>> (external_subprogram | module | submodule | block_data | main_program) {
  pin = 1
  recoverWhile = program_unit_recover
}
private program_unit_recover ::= !(eol | end_unit_keys)
private end_unit_keys ::= end | endprogram | endmodule | endfunction | endsubroutine | endsubmodule
// R203
private external_subprogram ::= function_subprogram | subroutine_subprogram
// R204 - 206 are included into execution_part_construct to be in block
// We prefer to parse more and then check
// R207
private declaration_construct ::= derived_type_def | entry_stmt | format_stmt | enum_def
                        | interface_block | parameter_stmt | procedure_declaration_stmt
                        | other_specification_stmt | type_declaration_stmt | stmt_function_stmt
// R208 is in R801
// R209
private execution_part_construct ::= !(label? end_block_keys) (executable_construct | use_stmt
                                    | import_stmt | implicit_stmt | declaration_construct) {
  pin=1
  recoverWhile=block_recover
}
private block_recover ::= !(eol | end_block_keys) // recover doesn't eat what it is not necessary to eat
private end_block_keys ::= end | endblock | endcritical | enddo | endfunction | endif | endmodule | endprocedure
                         | endprogram | endselect | endsubroutine | else | elseif | endassociate | case | contains
// R210
internal_subprogram_part ::= contains_stmt (eol | internal_subprogram)* { pin = 1 }
// R211
internal_subprogram ::= !(label? (end_unit_keys | endprocedure)) (function_subprogram | subroutine_subprogram) {
  pin = 1
  recoverWhile=internal_subprogram_recover
}
private internal_subprogram_recover ::= !(eol | end | endfunction | endsubprogram | endprocedure)
// R212
other_specification_stmt ::=  access_stmt       |  allocatable_stmt |  asynchronous_stmt
                           |  bind_stmt         |  codimension_stmt |  common_stmt
                           |  data_stmt         |  dimension_stmt   |  equivalence_stmt
                           |  external_stmt     |  intent_stmt      |  intrinsic_stmt
                           |  namelist_stmt     |  optional_stmt    |  pointer_stmt
                           |  protected_stmt    |  save_stmt        |  target_stmt
                           |  volatile_stmt     |  value_stmt
                           |  contiguous_stmt
// R213
private executable_construct ::= action_stmt   | associate_construct | block_construct  | case_construct
                       | critical_construct    | do_construct        | forall_construct | if_construct
                       | select_type_construct | where_construct
// R214
private action_stmt ::= allocate_stmt   | assignment_stmt           | backspace_stmt
                | call_stmt             | close_stmt                | continue_stmt
                | cycle_stmt            | deallocate_stmt           | endfile_stmt
                | error_stop_stmt       | exit_stmt                 | flush_stmt
                | forall_stmt           | goto_stmt                 | if_stmt
                | inquire_stmt          | lock_stmt                 | nullify_stmt
                | open_stmt             | pointer_assignment_stmt   | print_stmt
                | read_stmt             | return_stmt               | rewind_stmt
                | stop_stmt             | sync_all_stmt             | sync_images_stmt
                | sync_memory_stmt      | unlock_stmt               | wait_stmt
                | where_stmt            | write_stmt                | arithmetic_if_stmt
                | computed_goto_stmt
                // deleted
                | pause_stmt            | assign_stmt               | assigned_goto_stmt
// R215 is trivial

// Clause 3 (probably ready)
// R301, R302, R303 are implemented is lexer 'name' is replaced by 'identifier'
// R304, R305 are implemented in Clause 7
// R306, R307, R308 are trivial
// R309, R310, R311 are excess
// R312
external label ::= parseLabel

// Clause 4
// R401
private type_param_value ::= '*' | ':' | expr
// R402
private type_spec ::= intrinsic_type_spec | derived_type_spec
// R403
private declaration_type_spec ::= intrinsic_type_spec | (type '(' (intrinsic_type_spec | derived_type_spec)')')
                                | (classkwd '(' (derived_type_spec | '*') ')')
// R404
intrinsic_type_spec ::= ((integer | real | complex | logical) (kind_selector | nonstandard_kind_selector)?) | (double precision) | (character (char_selector)?)
// R405
kind_selector ::= '(' (kind '=')? expr ')' {pin = 2}
nonstandard_kind_selector ::= '*' expr { pin = 1 }
// R406
signed_int_literal ::= ('+' | '-')? integerliteral
// R407 - 411 are trivial or implemented in lexer
// R412
signed_real_literal ::= ('+' | '-')? (floatingpointliteral | doubleprecisionliteral)
// R412 - 416 are implemented in lexer
// R417
complex_literal ::= '(' ri_part ',' ri_part ')' { pin = 3 }
// R418 - 419
private ri_part ::= signed_int_literal | signed_real_literal | identifier
// R420
char_selector ::= length_selector | ('(' len '=' type_param_value ',' kind '=' expr ')')
                 | ('(' type_param_value ',' (kind '=')? expr ')')
                 | ('(' kind '=' expr (',' len '=' type_param_value)? ')')
// R421
length_selector ::= ('(' (len '=')? type_param_value ')') | ('*' char_length (',')?)
// R422
char_length ::= ('(' type_param_value ')') | integerliteral
// R423 - 424 are implemented in lexer
// R425
derived_type_def ::= derived_type_stmt type_param_def_stmt* private_or_sequence* component_part
                     type_bound_procedure_part? end_type_stmt { pin = 1 }
// R426
derived_type_stmt ::= label? type ((',' <<list type_attr_spec>>)? '::')? identifier ('(' <<list identifier>> ')')? eol { pin = 2 }
// R427
type_attr_spec ::= abstract | access_spec | bindckwd | (extends '(' identifier ')')
// R428
private private_or_sequence ::= label? (private | sequence) eol { pin = 2 }
// R429
end_type_stmt ::= label? ((end type) | endtype) identifier? { pin = 2 }
// R430 is trivial
// R431
type_param_def_stmt ::= integer (kind_selector)? ',' type_param_attr_spec '::' <<list type_param_decl>>
// R432
type_param_decl ::= identifier ('=' expr)?
// R433
type_param_attr_spec ::= kind | len
// R434
component_part ::= (eol | component_def_stmt)*
// R435
component_def_stmt ::= !(label? (type_end_keys | contains)) label? (data_component_def_stmt | proc_component_def_stmt) {
 pin = 1
 recoverWhile = component_def_stmt_recover
}
private component_def_stmt_recover ::= !(eol | type_end_keys | contains)
// R436
data_component_def_stmt ::= declaration_type_spec ((',' <<list component_attr_spec>>)? '::')? <<list component_decl>>
// R437
component_attr_spec ::= access_spec | allocatable | (codimension '[' coarray_spec ']')
                       | contiguous | (dimension '(' component_array_spec ')') | pointer
// R438
component_decl ::= identifier ('(' component_array_spec ')')? ('[' coarray_spec ']')?
                   ('*' char_length)? (initialization)?
// R439
private component_array_spec ::= <<list explicit_shape_spec>> | <<list deferred_shape_spec>>
// R440
proc_component_def_stmt ::= procedure '(' proc_interface? ')'',' <<list proc_component_attr_spec>> '::' <<list proc_decl>> { pin = 1 }
// R441
proc_component_attr_spec ::= pointer | (pass ('(' identifier ')')?) | nopass | access_spec
// R442 is the same as R505
// R443 - 444 are trivial
// R445
type_bound_procedure_part ::= contains_stmt private_stmt? (eol | type_bound_proc_binding)*
// R446
private_stmt ::= label? private eol { pin = 2 }
// R447
private type_bound_proc_binding ::= !(label? type_end_keys) (type_bound_procedure_stmt | type_bound_generic_stmt | final_procedure_stmt) {
 pin = 1
 recoverWhile = type_proc_recover
}
private type_proc_recover ::= !(eol | type_end_keys)
private type_end_keys ::= (end | endtype)
// R448
type_bound_procedure_stmt ::= procedure (type_bound_procedure_stmt_part1 | type_bound_procedure_stmt_part2 ) { pin = 1 }
private type_bound_procedure_stmt_part1 ::= '(' identifier ')' ',' <<list binding_attr>> '::' <<list identifier>> { pin = 1 }
private type_bound_procedure_stmt_part2 ::= ((',' <<list binding_attr>>)? '::')? <<list type_bound_proc_decl>>
// R449
type_bound_proc_decl ::= identifier ('=>' identifier)?
// R450
type_bound_generic_stmt ::= generic (',' access_spec)? '::' generic_spec '=>' <<list identifier>> { pin = 1}
// R451
binding_attr ::= (pass ('(' identifier ')')?) | nopass | nonoverridable | deferred | access_spec
// R452
final_procedure_stmt ::= final '::' <<list identifier>> { pin = 1 }
// R453
derived_type_spec ::= identifier ('(' <<list type_param_spec>> ')')?
// R454
type_param_spec ::= (identifier '=')? type_param_value
// R455 is in clause 7
// R456
component_spec ::= (identifier '=') component_data_source
// R457
component_data_source ::= expr /*| variable*/ | proc_target
// R458
enum_def ::= enum_def_stmt (eol | enumerator_def_stmt)+ end_enum_stmt { pin = 1 }
// R459
enum_def_stmt ::= label? enum ',' bind '(' identifier ')' eol { pin = 4 }
// R460
enumerator_def_stmt ::= !(label? end_enum_keys) label? enumeratorkwd ('::')? <<list enumerator>> {
  pin = 1
  recoverWhile = enum_recover
}
private end_enum_keys ::= (end enum) | endenum
private enum_recover ::= !(eol | end_enum_keys)
// R461
enumerator ::= identifier ('=' expr)?
// R462
end_enum_stmt ::= label? ((end enum) | endenum) { pin = 2 }
// R463
boz_literal ::= binaryliteral | octalliteral | hexliteral
// R464 - R467 are implemented in lexer
// R468 is in clause 7
// R469
ac_spec ::= ((type_spec '::')? <<list ac_value>>) | (type_spec '::')
// R470 - 471 are trivial
// R472
ac_value ::= (expr | ac_implied_do) !'=' { pin = 2 }
// R473
ac_implied_do ::= '('<<list ac_value>> ',' id_loop_stmt ')'
// R474 - 475 are trivial

// Clause 5
// R501
type_declaration_stmt ::= declaration_type_spec ((',' attr_spec)* '::')? <<list entity_decl>> {pin=1}
// R502
attr_spec ::= access_spec | allocatable | asynchronous | (codimension '[' coarray_spec ']')
             | contiguous | (dimension '(' array_spec ')') | external
             | (intent '(' intent_spec ')') | intrinsic | language_binding_spec
             | optional | parameter | pointer | protected | save | target | value | volatile
// R503
entity_decl ::= identifier ('(' array_spec ')')? ('[' coarray_spec ']')?
                ('*' char_length)? initialization?
// R504 is trivial
// R505
private initialization ::= ('=' expr) | ('=>' designator) | ('=>' function_reference)
// R506 is trivial
// R507
private access_spec ::= (public | private)
// R508
language_binding_spec ::= bind '(' identifier (',' namekwd '=' expr)? ')'
// R509
private coarray_spec ::= <<list ':'>> | explicit_coshape_spec
// R510 is trivial
// R511
explicit_coshape_spec ::= ((expr ':')? expr ',')* (expr ':')? '*'
// R512 - 513 are trivial
// R514 is probably unused
// R515
private array_spec ::= assumed_size_spec | <<list implied_shape_spec>> | <<list explicit_shape_spec>>
                     | <<list assumed_shape_spec>> | <<list deferred_shape_spec>>
// R516
explicit_shape_spec ::= (expr ':')? expr
// R517 - 518 are trivial
// R519
assumed_shape_spec ::= (expr)? ':'
// R520
deferred_shape_spec ::= ':'
// R521
assumed_size_spec ::= (explicit_shape_spec ',')* (expr ':')? '*'
// R522
implied_shape_spec ::= (expr ':')? '*'
// R523
private intent_spec ::= in | out | inout
// R524
access_stmt ::= access_spec (('::')? <<list access_id>>)?
// R525
access_id ::= identifier | generic_spec // generic_spec includes identifier
// R526
allocatable_stmt ::= allocatable ('::')? <<list allocatable_decl>>
// R527
allocatable_decl ::= identifier ('(' array_spec ')')? ('[' coarray_spec ']')?
// R528
asynchronous_stmt ::= asynchronous ('::')? <<list identifier>> { pin = 1 }
// R529
bind_stmt ::= language_binding_spec ('::')? <<list bind_entity>>
// R530
bind_entity ::= identifier | ('/' identifier '/')
// R531
codimension_stmt ::= codimension ('::')? <<list codimension_decl>> { pin = 1 }
// R532
codimension_decl ::= identifier '[' coarray_spec ']'
// R533 unused in standard but works
contiguous_stmt ::= contiguous ('::')? <<list identifier>> { pin = 1 }
// R534
data_stmt ::= data data_stmt_set ((',')? data_stmt_set)*
// R535
data_stmt_set ::= <<list data_stmt_object>> '/' <<list data_stmt_value>> '/'
// R536
data_stmt_object ::= variable | data_implied_do
// R537
data_implied_do ::= '(' <<list data_i_do_object>> ',' identifier '=' expr ',' expr (',' expr)?  ')'
// R538
data_i_do_object ::= (data_ref | data_implied_do) !'=' { pin= 2 }
// R539 is trivial
// R540
data_stmt_value ::= (data_stmt_repeat '*')? data_stmt_constant
// R541
data_stmt_repeat ::= designator | constant
// R542
data_stmt_constant ::= designator | constant | signed_int_literal | signed_real_literal
                     | function_reference | structure_constructor
// R543 - 544 are trivial
// R545
dimension_stmt ::= dimension ('::')? identifier '(' array_spec ')' (',' identifier '(' array_spec ')')* { pin = 1 }
// R546
intent_stmt ::= intent '(' intent_spec ')' ('::')? <<list identifier>> { pin = 1 }
// R547
optional_stmt ::= optional ('::')? <<list identifier>> { pin = 1 }
// R548
parameter_stmt ::= parameter '(' <<list named_constant_def>> ')' {pin=1}
// R549
named_constant_def ::= identifier '=' expr
// R550
pointer_stmt ::= pointer ('::')? <<list pointer_decl>> { pin = 1 }
// R551
pointer_decl ::= identifier ('(' <<list deferred_shape_spec>> ')')?
// R552
protected_stmt ::= protected ('::')? <<list identifier>> { pin = 1 }
// R553
save_stmt ::= save (('::')? <<list saved_entity>>)?
// R554
saved_entity ::= identifier | ('/' identifier '/')
// R555 is trivial
// R556
target_stmt ::= target ('::')? <<list target_decl>> { pin = 1 }
// R557
target_decl ::= identifier ('(' array_spec ')')? ('[' coarray_spec ']')?
// R558
value_stmt ::= value ('::')? <<list identifier>> { pin = 1 }
// R559
volatile_stmt ::= volatile ('::')? <<list identifier>> { pin = 1 }
// R560
implicit_stmt ::= implicit (<<list implicit_spec>> | none) { pin = 2 }
// R561
implicit_spec ::= (declaration_type_spec '(' <<list letter_spec>> ')')
                 | ((integer | real | complex | logical | character) '(' <<list letter_spec>> ')')
// that's a crutch to parse intrinsic_type_spec without kindparam
// R562
letter_spec ::= identifier ('-' identifier)? { pin = 1 }
// R563
namelist_stmt ::= namelist '/' identifier '/' <<list identifier>> ((',')? '/' identifier '/' <<list identifier>>)* { pin = 1 }
// R564 is trivial
// R565
equivalence_stmt ::= equivalence <<list equivalence_set>> { pin = 1 }
// R566
equivalence_set ::= '(' equivalence_object ',' <<list equivalence_object>> ')'
// R567
equivalence_object ::= (identifier !('%' | '(' | '[')) | substring | data_ref
// R568
common_stmt ::= common (('/' identifier? '/') | '//')? <<list common_block_object>> ((',')? (('/' identifier? '/') | '//') <<list common_block_object>>)* { pin = 1 }
// R569
common_block_object ::= identifier ('(' array_spec ')')?

// Clause 6
// R601 is implemented in clause 7
// R602
private variable ::= designator //| expr
// R603 - 607 are trivial
// R608
substring ::= parent_string '(' substring_range ')'
// R609
parent_string ::= (identifier !('%' | '(' | '[')) | data_ref | stringliteral
// R610
substring_range ::= (expr)? ':' (expr)?
// R611
data_ref ::= part_ref ('%' part_ref)*
// R612
private part_ref ::= identifier ('(' <<list section_subscript>> ')')? (image_selector)?
// R613 - 614 are trivial
// R615 - 618 are excrescent
// R619 is trivial
// R620
section_subscript ::= subscript_triplet | expr
// R621
subscript_triplet ::= (expr)? ':' (expr)? (':' expr)?
// R622 - 623 are trivial
// R624
image_selector ::= '[' <<list expr>> ']'  { pin = 1 }
// R625
// R626
allocate_stmt ::= allocate '(' (type_spec '::')? <<list allocation>> (',' <<list parameters_spec>>)? ')' { pin = 1 }
// R627 is not for parser
// R628 - 630 are trivial
// R631
allocation ::= allocate_object ('(' <<list allocate_shape_spec>> ')')? ('[' allocate_coarray_spec ']')?
// R632
private allocate_object ::= (identifier !('%' | '(' | '[')) | data_ref
// R633
allocate_shape_spec ::= (expr ':')? expr
// R634 - 635 are trivial
// R636
allocate_coarray_spec ::= ( <<list allocate_coshape_spec>> ',' )? (expr ':')? '*'
// R637
allocate_coshape_spec ::= (expr ':')? expr
// R638
nullify_stmt ::= nullify '(' <<list pointer_object>> ')' { pin = 1 }
// R639
pointer_object ::= (identifier !('%' | '(' | '[')) | data_ref
// R640
deallocate_stmt ::= deallocate '(' <<list allocate_object>> (',' <<list parameters_spec>>)? ')' { pin = 1 }
// R641 is not for parser

// Clause 7
// expressions in bnf grammar must be defined in a special order
// R701 - R722 + R304 + R305 + R601
expr ::= def_binary_operator_expr
       | equiv_expr
       | or_expr
       | and_expr
       | not_expr
       | rel_expr
       | concat_expr
       | add_expr_group
       | mult_expr
       | power_expr
       | def_unary_operator_expr
       | primary

private add_expr_group ::= add_expr | unary_add_expr
def_binary_operator_expr ::= expr defined_binary_op expr
defined_binary_op ::= defoperator
equiv_expr  ::= expr ('.eqv.' | '.neqv.') expr
or_expr     ::= expr '.or.' expr
and_expr    ::= expr '.and.' expr
not_expr    ::= '.not.' expr
rel_expr    ::= expr rel_op expr
private rel_op ::= '.eq.' | '.ne.' | '.lt.' | '.le.' | '.gt.' | '.ge.'
                 | '=='   | '/='   | '<'    | '<='   | '>'    | '>='
concat_expr ::= expr '//' expr
add_expr    ::= expr ('+' | '-') expr
unary_add_expr ::= ('+' | '-') expr
mult_expr   ::= expr ('*' | '/') expr
power_expr  ::= expr '**' expr { rightAssociative=true } { extends=expr }
def_unary_operator_expr ::= defined_unary_op expr
private defined_unary_op ::= defoperator
private primary ::= constant | designator | structure_constructor | function_reference | array_constructor | paren /*| type_param_inquiry */
paren ::= '(' expr ')'
// R455
structure_constructor ::= derived_type_spec '(' <<list component_spec>> ')'
// R468
array_constructor ::= ('(/' ac_spec '/)') | ('[' ac_spec ']')
// R601
designator ::= (identifier !('%' | '(' | '[')) | data_ref | substring /*| array_section  | complex_part_designator */
// R304, R305 modified
constant ::= integerliteral | floatingpointliteral | doubleprecisionliteral
           | complex_literal | logical_literal | stringliteral | boz_literal
logical_literal ::= true | false

// R724 - 731 are trivial

// R732
assignment_stmt ::=  designator '=' expr {pin = 2} // it was a variable here in the standard but we don't want to match an expression
// R733
pointer_assignment_stmt ::= pointer_a_with_data_pointer | pointer_a_with_proc_pointer
private pointer_a_with_data_pointer ::= data_pointer_object (('(' <<list bounds_remapping>> ')')
                                | ('(' <<list bounds_spec>>')')?) '=>' variable { pin = 3 }
private pointer_a_with_proc_pointer ::= proc_pointer_object '=>' proc_target { pin = 2 }
// R734
data_pointer_object ::= (identifier !"%") | (variable '%' identifier)
// R735
bounds_spec ::= expr ':'
// R736
bounds_remapping ::= expr ':' expr
// R737 is trivial
// R738 + R739
proc_pointer_object ::= (identifier !"%") | (variable '%' identifier)
// R740
proc_target ::= expr | (variable '%' identifier) | identifier // last two options may be parsed as expr. Need to check later
// R741
where_stmt ::= where '(' expr ')' assignment_stmt { pin = 5}
// R742
where_construct ::= where_construct_stmt (label? (eol | where_body_construct))* (masked_elsewhere_stmt (label? (eol | where_body_construct))*)*
                    (elsewhere_stmt (label? (eol | where_body_construct))*)? end_where_stmt { pin = 1 }
// R743
where_construct_stmt ::= (identifier ':')? where '(' expr ')' eol { pin = 6 }
// R744
private where_body_construct ::= !(label? end_where_keys) (assignment_stmt | where_stmt | where_construct) {
  pin = 1
  recoverWhile = where_recover
}
private where_recover ::= !(eol | end_where_keys)
private end_where_keys ::= end | else | elsewhere | endwhere
// R745, R746 are trivial
// R747
masked_elsewhere_stmt ::= label? ((else where) | elsewhere) '(' expr ')' identifier? eol { pin = 3 }
// R748
elsewhere_stmt ::= label? ((else where) | elsewhere) identifier? eol { pin = 3 }
// R749
end_where_stmt ::= label? ((end where) | endwhere) identifier? { pin = 2 }
// R750
forall_construct ::= forall_construct_stmt (label? (eol | forall_body_construct))* end_forall_stmt { pin = 1 }
// R751
forall_construct_stmt ::= (identifier ':')? forall forall_header eol { pin = 4 }
// R752
forall_header ::= '(' (type_spec '::')? forall_triplet_spec+ (expr)? ')' {pin=1}
// R753 + 754 + 755
forall_triplet_spec ::= identifier '=' expr ':' expr (':' expr)? {pin=2}
// R756
private forall_body_construct ::= !(label? end_forall_keys) (forall_assignment_stmt | where_construct | where_stmt
                        | forall_construct | forall_stmt) {
  pin = 1
  recoverWhile = forall_recover
}
private forall_recover ::= !(eol | end_forall_keys)
private end_forall_keys ::= end | endforall
// R757
private forall_assignment_stmt ::= assignment_stmt | pointer_assignment_stmt
// R758
end_forall_stmt ::= label? ((end forall) | endforall) identifier? { pin = 2 }
// R759
forall_stmt ::= forall forall_header forall_assignment_stmt { pin = 3 }


// Clause 8
// R801 + R208 we parse statements in any order while the standard has some restrictions. We'll check them in code revisions
block ::= (label? (eol | execution_part_construct))*
// R802
associate_construct ::= associate_stmt block end_associate_stmt { pin = 1 }
// R803
associate_stmt ::= (identifier ':')? associate <<list association>> eol { pin = 2 }
// R804
association ::= identifier '=>' selector { pin = 2 }
// R805
private selector ::= expr | variable
// R806
end_associate_stmt ::= label? ((end associate) | endassociate) (identifier)? { pin = 2 }
// R807
block_construct ::= block_stmt block end_block_stmt { pin = 1 }
// R808
block_stmt ::= (identifier ':')? blockkwd eol { pin = 3 }
// R809
end_block_stmt ::= label? ((end blockkwd) | endblock) (identifier)? {pin = 2 }
// R810
critical_construct ::= critical_stmt block end_critical_stmt { pin = 1 }
// R811
critical_stmt ::= (identifier ':')? critical eol { pin = 2 }
// R812
end_critical_stmt ::= label? ((end critical) | endcritical) (identifier)? { pin = 2 }
// R813 simplified compared to standard
external labeled_do_construct ::= parseLabeledDoConstruct
private do_construct ::= labeled_do_construct | nonlabel_do_construct
// R814
nonlabel_do_construct ::= nonlabel_do_stmt block end_do { pin = 1}
// R815 unused
// R816
//label_do_stmt ::= (identifier ':')? do label loop_control? eol { pin = 3 }
// R817
nonlabel_do_stmt ::= (identifier ':')? do loop_control? eol { pin = 2 }
// R818
loop_control ::= id_loop_stmt | while_loop_stmt | concurrent_loop_stmt
private id_loop_stmt ::= variable '=' expr ',' expr (',' expr)? {pin=1}
private while_loop_stmt ::= while '(' expr ')' {pin=1}
private concurrent_loop_stmt ::= concurrent forall_header {pin = 1}
// R819, R820 are trivial
// R821
private end_do ::= end_do_stmt //| continue at the end of a loop is f77 specific feature
// R822
end_do_stmt ::= label? (end do | enddo) identifier? { pin = 2}
// R823 - 830 are parsed manually
// R831
cycle_stmt ::= cycle (identifier)? { pin = 1 }
// R832
if_construct ::= if_then_stmt block (else_if_stmt block)* (else_stmt block)? end_if_stmt { pin = 1 }
// R833
if_then_stmt ::= (identifier ':')? if '(' expr ')' then eol {pin=6}
// R834
else_if_stmt ::= label? ((else if)|elseif) '(' expr ')' then identifier? eol { pin = 2 }
// R835
else_stmt ::= label? else identifier? eol { pin = 2 }
// R836
end_if_stmt ::= label? ((end if)|endif) identifier? { pin = 2 }
// R837
if_stmt ::= if '(' expr ')' action_stmt {pin=5}
// R838
case_construct ::= select_case_stmt (case_stmt block)* end_select_stmt { pin = 1 }
// R839
select_case_stmt ::= (identifier ':')? select case '(' expr ')' eol { pin = 3 }
// R840
case_stmt ::= label? case case_selector (identifier)? eol { pin = 2 }
// R841
end_select_stmt ::= label? ((end select) | endselect ) (identifier)? { pin = 2 }
// R842 is trivial
// R843
case_selector ::= ('(' <<list case_value_range>> ')') | default
// R844
case_value_range ::= (expr ':' expr) | (expr ':') | expr | (':' expr)
// R845 is trivial
// R846
select_type_construct ::= select_type_stmt (type_guard_stmt block)* end_select_stmt { pin = 1 }
// R847
select_type_stmt ::= (identifier ':')? select type '(' (identifier '=>')? selector ')' { pin = 3 }
// R848
type_guard_stmt ::= (typeis_guard | classis_guard | classdefault_guard) identifier? { pin = 1 }
private typeis_guard ::= type is '(' type_spec ')' { pin = 1 }
private classis_guard ::= classkwd is '(' derived_type_spec ')' { pin = 2 }
private classdefault_guard ::= classkwd default { pin = 2 }
// R849 is a copy of R841
// R850
exit_stmt ::= exit (identifier)?
// R851
goto_stmt ::= ((go to) | goto) label { pin = 2 }
// R852 deprecated
computed_goto_stmt ::= ((go to) | goto) '(' <<list label>> ')' (',')? expr { pin = 2 }
// R853 deprecated
arithmetic_if_stmt ::= if '(' expr ')' label ',' label ',' label { pin = 5 }
// R854
continue_stmt ::= continue
// R855
stop_stmt ::= stop (expr)? { pin = 1 }
// R856
error_stop_stmt ::= error stop (expr)? { pin = 1 }
// R857 it trivial
// R858
sync_all_stmt ::= ((sync all) | syncall) ('(' ( <<list parameters_spec>> )? ')')? { pin = 1 }
// R859 is not for parser
// R860
sync_images_stmt ::= ((sync images) | syncimages) '(' image_set (',' <<list sync_stat>>)?')' { pin = 1 }
// R861
image_set ::= '*' | expr
// R862
sync_memory_stmt ::= ((sync memory) | syncmemory) ('(' (<<list parameters_spec>>)? ')')? { pin = 1 }
// R863
lock_stmt ::= lock '(' variable (',' <<list lock_stat>>)? ')' { pin = 1 }
// R864
lock_stat ::=  (identifier identifier '=' variable) | parameters_spec
// lock_stat ::= (acquired lock '=' variable) | sync_stat
// R865
unlock_stmt ::= unlock '(' variable (',' <<list sync_stat>>)? ')' { pin = 1 }
// R866 is trivial

// Clause 9 (ready)
// R901 don't need now
//io_unit ::= '*' | variable | expr
// R902, R903 are trivial
// R904
open_stmt ::= open '(' <<list parameters_spec>> ')' {pin = 1}
// R905 is not for parser
// R906, R907 are trivial
// R908
close_stmt ::= close '(' <<list parameters_spec>> ')' {pin = 1}
// R909 is not for parser
// R910
read_stmt ::= read (io_control_read | format_read) {pin = 1}
private io_control_read ::= '(' <<list parameters_spec>> ')' <<list input_item>>? { pin = 1}
private format_read ::= format (',' <<list input_item>>)?
// R911
write_stmt ::= write '(' <<list parameters_spec>> ')' <<list output_item>>? { pin= 1 }
// R912
print_stmt ::= print format (',' <<list output_item>>)? { pin = 1 }
// R913 is not for parser
// R914 is trivial
// R915
private format ::= '*' /*| label*/ | expr
// we can match label when it's really an expression, but expression matches a label too
// R916
input_item ::= variable | io_implied_do
// R917
output_item ::= io_implied_do | expr
// R918 + R920
io_implied_do ::= '(' <<list io_implied_do_object>> ',' id_loop_stmt ')' { pin = 4 }
// R919
io_implied_do_object ::= (input_item | output_item) !'=' { pin = 2 }
// R921 (unused maybe)
//dtv_type_spec ::= (type | classkwd) '(' derived_type_spec ')' { pin =1 }
// R922
wait_stmt ::= wait '(' <<list parameters_spec>> ')' { pin =1 }
// R923 is not for parser
// R924
backspace_stmt ::= backspace (('(' <<list parameters_spec>> ')') | expr ) { pin = 1 }
// R925
endfile_stmt ::= endfile (('(' <<list parameters_spec>> ')') | expr) { pin = 1 }
// R926
rewind_stmt ::= rewind (('(' <<list parameters_spec>> ')') | expr) { pin = 1}
// R927 + R929 are not for parser
// R928
flush_stmt ::= flush (('(' <<list parameters_spec>> ')') | expr) { pin = 1}
// R930
inquire_stmt ::= inquire (inquire_with_iolength | ('(' <<list parameters_spec>> ')'))  { pin = 1}
private inquire_with_iolength ::= '(' iolength '=' expr /*variable */')' <<list output_item>> { pin = 2}
// R931 is not for parser

// Clause 10
// R1001
format_stmt ::= formatstmt { pin = 1 }

// Clause 11
// R1101
main_program ::= program_stmt? block internal_subprogram_part? end_program_stmt {pin=1}
// R1102 +
program_stmt ::= label? programkwd identifier eol { pin = 2 }
// R1103 +
end_program_stmt ::=  label? (endprogram identifier? | end (programkwd identifier?)?) { pin = 2 }
// R1104
module ::= module_stmt block module_subprogram_part? end_module_stmt { pin = 1 }
// R1105
module_stmt ::= label? modulekwd identifier eol { pin = 2 }
// R1106
end_module_stmt ::= label? (endmodule identifier? | end (modulekwd identifier?)?) { pin = 2 }
// R1107
module_subprogram_part ::= contains_stmt (eol | module_subprogram)* { pin = 1 }
// R1108
module_subprogram ::= !(label? (end | endmodule | endsubmodule)) (function_subprogram | subroutine_subprogram | separate_module_subprogram) {
  pin = 1
  recoverWhile = module_subprogram_recover
}
private module_subprogram_recover ::= !(eol | end | endfunction | endsubprogram | endprocedure)
// R1109
use_stmt ::= use (use_stmt_rename | use_stmt_only) { pin = 1 }
private use_stmt_rename ::= ((',' module_nature)? '::')? identifier (',' <<list rename>>)
private use_stmt_only ::= ((',' module_nature)? '::')? identifier ',' only ':' (<<list only_stmt>>) { pin = 4 }
// R1110
private module_nature ::= intrinsic | nonintrinsic
// R1111
rename_stmt ::= (identifier '=>' identifier)
               |(operator '(' defoperator ')' '=>' operator '(' defoperator ')')
// R1112
only_stmt ::= generic_spec | identifier | rename_stmt
// R1113, R1114, R1115 are trivial
// R1116
submodule ::= submodule_stmt block module_subprogram_part? end_submodule_stmt { pin = 1 }
// R1117
submodule_stmt ::= label? submodulekwd '(' parent_identifier ')' identifier eol { pin = 2 }
// R1118
parent_identifier ::= identifier (':' identifier)?
// R1119
end_submodule_stmt ::= label? (endsubmodule identifier? | end (submodulekwd identifier?)?)  { pin = 2 }
// R1120
block_data ::= block_data_stmt block end_block_data_stmt { pin = 1 }
// R1121
block_data_stmt ::= label? (blockdata | (blockkwd data)) identifier? eol { pin = 2 }
// R1122
end_block_data_stmt ::= label? ((endblockdata identifier?)| (end (((blockkwd data) | blockdata) identifier?)?)
                      | (endblock data identifier?))  { pin = 2 }

// Clause 12
// R1201
interface_block ::= interface_stmt interface_specification* end_interface_stmt { pin = 1 }
// R1202
private interface_specification ::= !endinterface_keys (eol | interface_body | procedure_stmt) {
pin = 1
recoverWhile = interface_recover
}
private endinterface_keys ::= end | endinterface
private interface_recover ::= !(eol | endinterface_keys)
// R1203
interface_stmt ::= ((abstract interface) | (interface (generic_spec)?)) eol { pin = 1 }
// R1204
end_interface_stmt ::= label? ((end interface) | endinterface) (generic_spec)? { pin = 2 }
// R1205
interface_body ::= interface_function_body | interface_subroutine_body
private interface_function_body ::= function_stmt block? end_function_stmt { pin = 1 }
private interface_subroutine_body ::= subroutine_stmt block? end_subroutine_stmt { pin = 1 }
// R1206
procedure_stmt ::= (modulekwd)? procedure ('::')? <<list identifier>> { pin = 2 }
// R1207
generic_spec ::= identifier | (operator '(' defoperator ')')
              | assignment '(' '=' ')' | defined_io_generic_spec
// R1208
defined_io_generic_spec ::= read '(' (formatted | unformatted) ')'
                           | write '(' (formatted | unformatted) ')'
// R1209
import_stmt ::= import ('::'? <<list identifier>>) { pin =1 }
// R1210
external_stmt ::= external ('::')? <<list identifier>> { pin = 1 }
// R1211
procedure_declaration_stmt ::= procedure '(' proc_interface? ')' ((',' proc_attr_spec)* '::')? <<list proc_decl>> { pin = 1 }
// R1212
proc_interface ::= identifier | declaration_type_spec
// R1213
proc_attr_spec ::= access_spec | language_binding_spec | (intent '(' intent_spec ')')
                  | optional | pointer | save
// R1214
proc_decl ::= identifier ('=>' proc_pointer_init)?
// R1215 is trivial
// R1216
proc_pointer_init ::= function_reference | identifier
// R1217 is trivial
// R1218
intrinsic_stmt ::= intrinsic ('::')? <<list identifier>> { pin = 1 }
// R1219
function_reference ::= procedure_designator '(' <<list actual_arg_spec>> ')' { pin = 2 }
// R1220
call_stmt ::= call procedure_designator ('(' <<list actual_arg_spec>>? ')')?
// R1221
procedure_designator ::= (identifier !('%')) | (variable '%' identifier) | (data_ref '%' identifier)
// R1222
actual_arg_spec ::= (identifier '=')? actual_arg
// 1223
actual_arg ::= expr | alt_return_spec // expr matches variable, procedure-name and proc-component-ref
// 1224 deprecated
alt_return_spec ::= '*' label
// R1225
prefix ::= prefix_spec+ { pin = 1 }
// R1226
prefix_spec ::= declaration_type_spec | elemental | impure | modulekwd | pure | recursive
// R1227
function_subprogram ::= function_stmt block internal_subprogram_part? end_function_stmt { pin = 1 }
// R1228
function_stmt ::= label? prefix? function identifier '(' <<list identifier>>? ')' suffix? eol { pin = 3 }
// R1229 and R1230 are trivial
// R1231
suffix ::= (language_binding_spec (result '(' identifier ')')?) | (result '(' identifier ')' (language_binding_spec)?)
// R1232
end_function_stmt ::= label? ((end (function identifier?)?) | (endfunction identifier?)) { pin = 2 }
// R1233
subroutine_subprogram ::= subroutine_stmt block internal_subprogram_part? end_subroutine_stmt { pin = 1 }
// R1234
subroutine_stmt ::= label? prefix? subroutine identifier ('(' <<list dummy_arg>>? ')' language_binding_spec? )? eol { pin = 3 }
// R1235
dummy_arg ::= '*' | identifier
// R1236
end_subroutine_stmt ::= label? ((end (subroutine identifier?)?) | (endsubroutine identifier?)) { pin = 2 }
// R1237
separate_module_subprogram ::= mp_subprogram_stmt block internal_subprogram_part? end_mp_subprogram_stmt { pin = 1 }
// R1238
mp_subprogram_stmt ::= label? modulekwd procedure identifier eol { pin = 3 }
// R1239
end_mp_subprogram_stmt ::= label? ((end (procedure identifier?)?) | (endprocedure identifier?)) { pin = 2}
// R1240
entry_stmt ::= entry identifier ('(' <<list dummy_arg>>? ')' suffix? )? { pin = 1 }
// R1241
return_stmt ::= returnkwd (expr)? { pin = 1}
// R1242
contains_stmt ::= label? contains eol { pin = 2 }
// R1243
stmt_function_stmt ::= identifier '(' <<list identifier>>? ')' '=' expr { pin = 5 }

// deleted statements
pause_stmt ::= pause (expr)? { pin = 1 }
assign_stmt ::= assign label to variable { pin = 1 }
assigned_goto_stmt ::= (goto | (go to)) identifier (','? '(' <<list label>> ')' )?  { pin = 2 }


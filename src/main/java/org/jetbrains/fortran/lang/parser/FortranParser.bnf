{
  parserClass='org.jetbrains.fortran.lang.parser.FortranParser'
  implements='org.jetbrains.fortran.lang.psi.FortranCompositeElement'
  extends='org.jetbrains.fortran.lang.psi.impl.FortranCompositeElementImpl'

  elementTypeHolderClass='org.jetbrains.fortran.lang.FortranTypes'
  elementTypeClass='org.jetbrains.fortran.lang.psi.FortranCompositeElementType'
  tokenTypeClass='org.jetbrains.fortran.lang.psi.FortranTokenType'

  psiClassPrefix='Fortran'
  psiImplClassSuffix='Impl'
  psiPackage='org.jetbrains.fortran.lang.psi'
  psiImplPackage='org.jetbrains.fortran.lang.psi.impl'

//  parserUtilClass='org.rust.lang.core.parser.RustParserUtil'
//  psiImplUtilClass = ''
//  psiTreeUtilClass = ''
  generateTokenAccessors=true
  tokens=[
    EQ        = '='
    EQEQ      = 'regexp:==|.eq.'
    NEQ       = 'regexp:/=|.neq.'
    COLON     = ':'
    COLONCOLON = '::'
    PLUS      = '+'
    MINUS     = '-'
    MUL       = '*'
    POWER     = '**'
    DIV       = '/'
    DIVDIV    = '//'
    LPAR      = '('
    RPAR      = ')'
    LBRACKET  = '['
    RBRACKET  = ']'
    COMMA     = ','
    DOT       = '.'
    DOLLAR    = '$'
    PERC      = '%'
    AMP       = '&'
  //  SEMICOLON = ';'
    LT        = 'regexp:<|.lt.'
    LE        = 'regexp:<=|.le.'
    GT        = 'regexp:>|.gt.'
    GE        = 'regexp:>=|.ge.'
    QUEST     = '?'

    LOGICAL_EQ  = '.eqv.'
    LOGICAL_NEQ = '.neqv.'
    AND         = '.and.'
    OR          = '.or.'
    NOT         = '.not.'

    TRUE_KEYWORD  = '.true.'
    FALSE_KEYWORD = '.false.'
  ]
// какая-то магия
  extends(".*expr")=expr
  consumeTokenMethod(".*_expr|expr")="consumeTokenFast"
}

program_unit ::= main_program

private block_recover ::= !(eol | start_keys | end_keys)
private start_keys ::= identifier | if | do
private end_keys ::= end_program_stmt | else_if_stmt | else_stmt | end_if_stmt | end_do
// R208
execution_part ::= execution_part_construct*

// R209
private execution_part_construct ::= !end_keys executable_construct eol {
  pin=1
  recoverWhile=block_recover
}// | format-stmt | entry-stmt | data-stmt


// R213
private executable_construct ::= action_stmt/*| associate_construct | block_construct | case_construct
                       | critical_construct*/ | do_construct/* | forall_construct*/ | if_construct
                     /*  | select_type_construct | where_construct*/
// R214
private action_stmt ::= /*allocate-stmt
                |*/ assignment_stmt /*
                | backspace-stmt
                | call-stmt
                | close-stmt
                | continue-stmt
                | cycle-stmt
                | deallocate-stmt
                | end-function-stmt
                | end-mp-subprogram-stmt
                | end-program-stmt
                | end-subroutine-stmt
                | endfile-stmt
                | error-stop-stmt
                | exit-stmt
                | flush-stmt
                | forall-stmt
                | goto-stmt
               */ | if_stmt/*
                | inquire-stmt
                | lock-stmt
                | nullify-stmt
                | open-stmt
                | pointer-assignment-stmt
                | print-stmt
                | read-stmt
                | return-stmt
                | rewind-stmt
                | stop-stmt
                | sync-all-stmt
                | sync-images-stmt
                | sync-memory-stmt
                | unlock-stmt
                | wait-stmt
                | where-stmt
                | write-stmt
                | arithmetic-if-stmt
                | computed-goto-stmt*/

// Clause 3
label ::= integer_literal

// Clause 4
// R402
type_spec ::= intrinsic_type_spec //| derived_type_spec
// R404
intrinsic_type_spec ::= ((integer | real | complex | character | logical) (kind_selector)?) | (double precision)
// R405
kind_selector ::= '(' kind '=' expr ')' {pin = 2}

// Clause 6
// R602
private variable ::= designator | expr

// Clause 7
// R701
expr ::= def_binary_operator_expr
       | equiv_expr
       | or_expr
       | and_expr
       | not_expr
       | rel_expr
       | concat_expr
       | add_expr_group
       | mult_expr
       | power_expr
       | def_unary_operator_expr
       | primary

private add_expr_group ::= add_expr | unary_add_expr
def_binary_operator_expr ::= expr defined_binary_op expr
defined_binary_op ::= '.' identifier '.'
equiv_expr  ::= expr ('.eqv.' | '.neqv.') expr
or_expr     ::= expr '.or.' expr
and_expr    ::= expr '.and.' expr
not_expr    ::= '.not.' expr
rel_expr    ::= expr rel_op expr
private rel_op ::= '.eq.' | '.ne.' | '.lt.' | '.le.' | '.gt.' | '.ge.'
                 | '=='   | '/='   | '<'    | '<='   | '>'    | '>='
concat_expr ::= expr '//' expr
add_expr    ::= expr ('+' | '-') expr
unary_add_expr ::= ('+' | '-') expr
mult_expr   ::= expr ('*' | '/') expr
power_expr  ::= expr '**' expr { rightAssociative=true } { extends=expr }
def_unary_operator_expr ::= defined_unary_op expr
private defined_unary_op ::= '.' identifier '.'
private primary ::= constant | designator | paren
paren ::= '(' expr ')'

designator ::= identifier
constant ::= integer_literal | floating_point_literal | double_precision_literal
           | string_literal | logical_constant
logical_constant ::= '.true.' | '.false.'
// R732
assignment_stmt ::= variable '=' expr {pin = 2}

// R752
forall_header ::= '(' (type_spec '::')? forall_triplet_spec+ (expr)? ')'
// R753 + 754 + 755
forall_triplet_spec ::= identifier '=' expr ':' expr (':' expr)?


// Clause 8
// R801
block ::= execution_part_construct*

// R813
private do_construct ::= block_do_construct // | nonblock_do_constract
// R814  + 820
block_do_construct ::= do_stmt block end_do { pin = 1}
// R815 + 818 + 819
private do_stmt ::= label_do_stmt | nonlabel_do_stmt
// R816
label_do_stmt ::= (identifier ':')? do label loop_control? eol { pin = 3 }
// R817
nonlabel_do_stmt ::= (identifier ':')? do loop_control? eol { pin = 2 }
// R818
loop_control ::= (identifier '=' expr ',' expr (',' expr)?) | (while '(' expr ')') | (concurrent forall_header) {pin = 1}
// R821 + 854
private end_do ::= end_do_stmt | continue
// R822
end_do_stmt ::= (end do | enddo) identifier? { pin = 1}
// R832
if_construct ::= if_then_stmt block (else_if_stmt block)* (else_stmt block)? end_if_stmt {pin = 1}

// R833
if_then_stmt ::= (identifier ':')? if '(' expr ')' then eol {pin=6}
// R834
else_if_stmt ::= ((else if)|elseif) '(' expr ')' then identifier? eol {pin=1}
// R835
else_stmt ::= else identifier? eol {pin=1}
// R836
end_if_stmt ::= ((end if)|endif) identifier? {pin=1}
// R837
if_stmt ::= if '(' expr ')' action_stmt {pin=5}

// R1101
main_program ::= program_stmt? /*specification_part?*/ execution_part?
            /*internal_subprogram_part*/ end_program_stmt {pin=1}

// R1102 +
program_stmt ::= program identifier eol {pin=1}

// R1103 +
end_program_stmt ::=  (endprogram identifier? | end (program identifier?)?) eol? {pin = 1}

// That's a cap. Must be removed in the final version
cap ::= identifier | line_comment | white_space

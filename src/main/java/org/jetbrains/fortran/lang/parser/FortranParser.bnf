{
  parserClass='org.jetbrains.fortran.lang.parser.FortranParser'
  implements='org.jetbrains.fortran.lang.psi.FortranCompositeElement'
  extends='org.jetbrains.fortran.lang.psi.impl.FortranCompositeElementImpl'

  elementTypeHolderClass='org.jetbrains.fortran.lang.FortranTypes'
  elementTypeClass='org.jetbrains.fortran.lang.psi.FortranCompositeElementType'
  tokenTypeClass='org.jetbrains.fortran.lang.psi.FortranTokenType'

  psiClassPrefix='Fortran'
  psiImplClassSuffix='Impl'
  psiPackage='org.jetbrains.fortran.lang.psi'
  psiImplPackage='org.jetbrains.fortran.lang.psi.impl'

//  parserUtilClass='org.rust.lang.core.parser.RustParserUtil'
//  psiImplUtilClass = ''
//  psiTreeUtilClass = ''
  generateTokenAccessors=true
  tokens=[
    EQ        = '='
    EQEQ      = 'regexp:==|.eq.'
    NEQ       = 'regexp:/=|.neq.'
    COLON     = ':'
    COLONCOLON = '::'
    PLUS      = '+'
    MINUS     = '-'
    MUL       = '*'
    POWER     = '**'
    DIV       = '/'
    DIVDIV    = '//'
    LPAR      = '('
    RPAR      = ')'
    LBRACKET  = '['
    RBRACKET  = ']'
    COMMA     = ','
    DOT       = '.'
    DOLLAR    = '$'
    PERC      = '%'
    AMP       = '&'
  //  SEMICOLON = ';'
    LT        = 'regexp:<|.lt.'
    LE        = 'regexp:<=|.le.'
    GT        = 'regexp:>|.gt.'
    GE        = 'regexp:>=|.ge.'
    QUEST     = '?'

    LOGICAL_EQ  = '.eqv.'
    LOGICAL_NEQ = '.neqv.'
    AND         = '.and.'
    OR          = '.or.'
    NOT         = '.not.'

    TRUE_KEYWORD  = '.true.'
    FALSE_KEYWORD = '.false.'

    POINTER_ASSMNT = '=>'
  ]
// какая-то магия
  extends(".*expr")=expr
  consumeTokenMethod(".*_expr|expr")="consumeTokenFast"
}

program_unit ::= eol* main_program

private block_recover ::= !(eol | start_keys | end_keys)
private start_keys ::= identifier | if | do
private end_keys ::= end_program_stmt | else_if_stmt | else_stmt | end_if_stmt | end_do

// R204
specification_part ::= use_stmt* import_stmt* implicit_part? declaration_construct*
// R205
implicit_part ::= implicit_part_stmt* implicit_stmt
// R206
implicit_part_stmt ::= implicit_stmt | parameter_stmt /*| format_stmt | entry_stmt*/
// R207
declaration_construct ::= /*derived-type-def | entry-stmt | enum-def | format-stmt
                        | interface-block | */parameter_stmt/* | procedure-declaration-stmt
                        | other-specification-stmt*/ | type_declaration_stmt// | stmt-function-stmt

// R208
execution_part ::= execution_part_construct*

// R209
private execution_part_construct ::= !end_keys executable_construct? eol {
  pin=1
  recoverWhile=block_recover
}// | format-stmt | entry-stmt | data-stmt


// R213
private executable_construct ::= action_stmt/*| associate_construct | block_construct | case_construct
                       | critical_construct*/ | do_construct/* | forall_construct*/ | if_construct
                     /*  | select_type_construct | where_construct*/
// R214
private action_stmt ::= /*allocate-stmt
                |*/ assignment_stmt /*
                | backspace-stmt
                | call-stmt
                | close-stmt
                | continue-stmt
                | cycle-stmt
                | deallocate-stmt
                | end-function-stmt
                | end-mp-subprogram-stmt
                | end-program-stmt
                | end-subroutine-stmt
                | endfile-stmt
                | error-stop-stmt
                | exit-stmt
                | flush-stmt
                | forall-stmt
                | goto-stmt
               */ | if_stmt/*
                | inquire-stmt
                | lock-stmt
                | nullify-stmt
                | open-stmt
                | pointer-assignment-stmt
                | print-stmt
                | read-stmt
                | return-stmt
                | rewind-stmt
                | stop-stmt
                | sync-all-stmt
                | sync-images-stmt
                | sync-memory-stmt
                | unlock-stmt
                | wait-stmt
                | where-stmt
                | write-stmt
                | arithmetic-if-stmt
                | computed-goto-stmt*/

// Clause 3
label ::= integer_literal

// Clause 4
// R401
private type_param_value ::= '*' | ':' | expr
// R402
type_spec ::= intrinsic_type_spec //| derived_type_spec
// R403
private declaration_type_spec ::= intrinsic_type_spec // | много всего другого
// R404
intrinsic_type_spec ::= ((integer | real | complex | character | logical) (kind_selector)?) | (double precision)
// R405
kind_selector ::= '(' kind '=' expr ')' {pin = 2}

// Clause 5
// R501
type_declaration_stmt ::= declaration_type_spec ((',' attr_spec)* '::')? entity_decl_list eol
// R502
attr_spec ::= access_spec | allocatable | asynchronous | (codimension '[' coarray_spec ']')
             | contiguous | (dimension '(' array_spec ')') | external
             | (intent '(' intent_spec ')') | intrinsic | language_binding_spec
             | optional | parameter | pointer | protected | save | target | value | volatile
// R503
private entity_decl_list ::= entity_decl (',' entity_decl)*
entity_decl ::= identifier ('(' array_spec ')')? ('[' coarray_spec ']')?
                ('*' char_length)? initialization?
// R507
private access_spec ::= (public | private)
// R508
language_binding_spec ::= bind '(' (',' bindname '=' expr)? ')'
// R509
private coarray_spec ::= deferred_coshape_spec_list// | explicit_coshape_spec
// R510
deferred_coshape_spec_list ::= ':' (',' ':')*
// R515
private array_spec ::= explicit_shape_spec_list | assumed_shape_spec_list
                | deferred_shape_spec_list //| assumed_size_spec | implied_shape_spec_list
// R516
private explicit_shape_spec_list ::= explicit_shape_spec (',' explicit_shape_spec)*
explicit_shape_spec ::= (expr ':')? expr
// R519
private assumed_shape_spec_list ::= assumed_shape_spec (',' assumed_shape_spec)*
assumed_shape_spec ::= (expr)? ':'
// R520
private deferred_shape_spec_list ::= deferred_shape_spec (',' deferred_shape_spec)*
deferred_shape_spec ::= (expr)? ':'

// R523
private intent_spec ::= in | out | inout
// R442
char_length ::= ('(' type_param_value ')') | integer_literal
// R548
parameter_stmt ::= parameter '(' named_constant_def_list ')' {pin=1}
// R549
private named_constant_def_list ::= named_constant_def (',' named_constant_def)*
named_constant_def ::= identifier '=' expr
// R560
implicit_stmt ::= implicit (implisit_spec_list | none) { pin = 1}
// R561
private implisit_spec_list ::= implicit_spec (',' implicit_spec)*
implicit_spec ::= declaration_type_spec '(' letter_spec_list ')'
// R562
private letter_spec_list ::= letter_spec (',' letter_spec)*
letter_spec ::= id ('-' id)
// Clause 6
// R602
private variable ::= designator | expr

// Clause 7
// R701
expr ::= def_binary_operator_expr
       | equiv_expr
       | or_expr
       | and_expr
       | not_expr
       | rel_expr
       | concat_expr
       | add_expr_group
       | mult_expr
       | power_expr
       | def_unary_operator_expr
       | primary

private add_expr_group ::= add_expr | unary_add_expr
def_binary_operator_expr ::= expr defined_binary_op expr
defined_binary_op ::= '.' identifier '.'
equiv_expr  ::= expr ('.eqv.' | '.neqv.') expr
or_expr     ::= expr '.or.' expr
and_expr    ::= expr '.and.' expr
not_expr    ::= '.not.' expr
rel_expr    ::= expr rel_op expr
private rel_op ::= '.eq.' | '.ne.' | '.lt.' | '.le.' | '.gt.' | '.ge.'
                 | '=='   | '/='   | '<'    | '<='   | '>'    | '>='
concat_expr ::= expr '//' expr
add_expr    ::= expr ('+' | '-') expr
unary_add_expr ::= ('+' | '-') expr
mult_expr   ::= expr ('*' | '/') expr
power_expr  ::= expr '**' expr { rightAssociative=true } { extends=expr }
def_unary_operator_expr ::= defined_unary_op expr
private defined_unary_op ::= '.' identifier '.'
private primary ::= constant | designator | paren
paren ::= '(' expr ')' { pin=1}

designator ::= identifier
constant ::= integer_literal | floating_point_literal | double_precision_literal
           | string_literal | logical_constant
logical_constant ::= '.true.' | '.false.'
// R732
assignment_stmt ::= variable '=' expr {pin = 2}

// R752
forall_header ::= '(' (type_spec '::')? forall_triplet_spec+ (expr)? ')' {pin=1}
// R753 + 754 + 755
forall_triplet_spec ::= identifier '=' expr ':' expr (':' expr)? {pin=2}


// Clause 8
// R801
block ::= execution_part_construct*

// R813
private do_construct ::= block_do_construct // | nonblock_do_constract
// R814  + 820
block_do_construct ::= do_stmt block end_do { pin = 1}
// R815 + 818 + 819
private do_stmt ::= label_do_stmt | nonlabel_do_stmt
// R816
label_do_stmt ::= (identifier ':')? do label loop_control? eol { pin = 3 }
// R817
nonlabel_do_stmt ::= (identifier ':')? do loop_control? eol { pin = 2 }
// R818
loop_control ::= id_loop_stmt | while_loop_stmt | concurrent_loop_stmt
private id_loop_stmt ::= identifier '=' expr ',' expr (',' expr)? {pin=1}
private while_loop_stmt ::= while '(' expr ')' {pin=1}
private concurrent_loop_stmt ::= concurrent forall_header {pin = 1}
// R821 + 854
private end_do ::= end_do_stmt | continue
// R822
end_do_stmt ::= (end do | enddo) identifier? { pin = 1}
// R832
if_construct ::= if_then_stmt block (else_if_stmt block)* (else_stmt block)? end_if_stmt {pin = 1}

// R833
if_then_stmt ::= (identifier ':')? if '(' expr ')' then eol {pin=6}
// R834
else_if_stmt ::= ((else if)|elseif) '(' expr ')' then identifier? eol {pin=1}
// R835
else_stmt ::= else identifier? eol {pin=1}
// R836
end_if_stmt ::= ((end if)|endif) identifier? {pin=1}
// R837
if_stmt ::= if '(' expr ')' action_stmt {pin=5}

// R1101
main_program ::= program_stmt? specification_part? execution_part?
            /*internal_subprogram_part*/ end_program_stmt {pin=1}

// R1102 +
program_stmt ::= program identifier eol {pin=1}

// R1103 +
end_program_stmt ::=  (endprogram identifier? | end (program identifier?)?) eol? {pin = 1}

// R1109
use_stmt ::= use (use_stmt_rename | use_stmt_only) {pin = 1}
private use_stmt_rename ::= ((',' module_nature)? '::')? identifier (',' rename_list)
private use_stmt_only ::= ((',' module_nature)? '::')? identifier ',' only ':' (only_list) { pin = 4}
// R1110
private module_nature ::= intrinsic | non_intrinsic
// R1111
private rename_list ::= rename_stmt (',' rename_stmt)*
rename_stmt ::= (identifier '=>' identifier)
               |(operator '(' '.' identifier '.' ')' '=>' operator '(' '.' identifier '.' ')')
// R1112
private only_list ::= only_stmt (',' only_stmt)*
only_stmt ::= generic_spec | identifier | rename_stmt

// Clause 12
// R1207
generic_spec ::= identifier | (operator '(' '.' identifier '.' ')')
              | assignment '(' '=' ')' | defined_io_generic_spec
// R1208
defined_io_generic_spec ::= read '(' (formatted | unformatted) ')'
                           | write '(' (formatted | unformatted) ')'
// R1209
import_stmt ::= import ('::'? name_list) { pin =1 }
private name_list ::= identifier (',' identifier)*


// That's a cap. Must be removed in the final version
cap ::= line_comment //| white_space

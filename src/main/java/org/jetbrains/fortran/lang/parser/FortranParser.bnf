{
  parserClass='org.jetbrains.fortran.lang.parser.FortranParser'
  implements='org.jetbrains.fortran.lang.psi.FortranCompositeElement'
  extends='org.jetbrains.fortran.lang.psi.impl.FortranCompositeElementImpl'

  elementTypeHolderClass='org.jetbrains.fortran.lang.FortranTypes'
  elementTypeClass='org.jetbrains.fortran.lang.psi.FortranCompositeElementType'
  tokenTypeClass='org.jetbrains.fortran.lang.psi.FortranTokenType'

  psiClassPrefix='Fortran'
  psiImplClassSuffix='Impl'
  psiPackage='org.jetbrains.fortran.lang.psi'
  psiImplPackage='org.jetbrains.fortran.lang.psi.impl'

//  parserUtilClass='org.rust.lang.core.parser.RustParserUtil'
//  psiImplUtilClass = ''
//  psiTreeUtilClass = ''
  generateTokenAccessors=true
  tokens=[
    EQ        = '='
    EQEQ      = 'regexp:==|.eq.'
    NEQ       = 'regexp:/=|.neq.'
    COLON     = ':'
    COLONCOLON = '::'
    PLUS      = '+'
    MINUS     = '-'
    MUL       = '*'
    POWER     = '**'
    DIV       = '/'
    DIVDIV    = '//'
    LPAR      = '('
    RPAR      = ')'
    LBRACKET  = '['
    RBRACKET  = ']'
    COMMA     = ','
    DOT       = '.'
    DOLLAR    = '$'
    PERC      = '%'
    AMP       = '&'
  //  SEMICOLON = ';'
    LT        = 'regexp:<|.lt.'
    LE        = 'regexp:<=|.le.'
    GT        = 'regexp:>|.gt.'
    GE        = 'regexp:>=|.ge.'
    QUEST     = '?'

    LOGICAL_EQ  = '.eqv.'
    LOGICAL_NEQ = '.neqv.'
    AND         = '.and.'
    OR          = '.or.'
    NOT         = '.not.'

    TRUE_KEYWORD  = '.true.'
    FALSE_KEYWORD = '.false.'

    POINTER_ASSMNT = '=>'
  ]

  extends(".*expr")=expr
  consumeTokenMethod(".*_expr|expr")="consumeTokenFast"
}

program_unit ::= eol* main_program

private block_recover ::= !(eol | end_keys) // recover doesn't eat what it is not necessary to eat
private end_keys ::= end | endprogram | endif | enddo | else | elseif

// R204
specification_part ::= use_stmt* import_stmt* implicit_part? declaration_construct*
// R205
implicit_part ::= implicit_part_stmt* implicit_stmt
// R206
implicit_part_stmt ::= implicit_stmt | parameter_stmt /*| format_stmt | entry_stmt*/
// R207
declaration_construct ::= /*derived-type-def | entry-stmt | enum-def | format-stmt
                        | interface-block | */parameter_stmt/* | procedure-declaration-stmt
                        | other-specification-stmt*/ | type_declaration_stmt// | stmt-function-stmt


// R209
private execution_part_construct ::= !end_keys executable_construct {
  pin=1
  recoverWhile=block_recover
}// | format-stmt | entry-stmt | data-stmt


// R213
private executable_construct ::= action_stmt/*| associate_construct | block_construct | case_construct
                       | critical_construct*/ | do_construct/* | forall_construct*/ | if_construct
                     /*  | select_type_construct | where_construct*/
// R214
private action_stmt ::= /*allocate-stmt
                |*/ assignment_stmt
                | backspace_stmt/*
                | call-stmt*/
                | close_stmt
                | continue_stmt/*
                | cycle-stmt
                | deallocate-stmt
                | end-function-stmt
                | end-mp-subprogram-stmt
                | end-program-stmt
                | end-subroutine-stmt*/
                | endfile_stmt/*
                | error-stop-stmt
                | exit-stmt*/
                | flush_stmt/*
                | forall-stmt
                | goto-stmt
               */ | if_stmt
                | inquire_stmt/*
                | lock-stmt
                | nullify-stmt*/
                | open_stmt
              /*  | pointer-assignment-stmt*/
                | print_stmt
                | read_stmt/*
                | return-stmt*/
                | rewind_stmt/*
                | stop-stmt
                | sync-all-stmt
                | sync-images-stmt
                | sync-memory-stmt
                | unlock-stmt*/
                | wait_stmt/*
                | where-stmt*/
                | write_stmt/*
                | arithmetic-if-stmt
                | computed-goto-stmt*/

// Clause 3
label ::= integer_literal {
  implements = [ "org.jetbrains.fortran.lang.psi.ext.FortranNamedElement" ]
  mixin = "org.jetbrains.fortran.lang.psi.ext.FortranLabelImplMixin"
}
// Clause 4
// R401
private type_param_value ::= '*' | ':' | expr
// R402
type_spec ::= intrinsic_type_spec //| derived_type_spec
// R403
private declaration_type_spec ::= intrinsic_type_spec // | много всего другого
// R404
intrinsic_type_spec ::= ((integer | real | complex | character | logical) (kind_selector)?) | (double precision)
// R405
kind_selector ::= '(' (kind '=')? expr ')' {pin = 2}

// Clause 5
// R501
type_declaration_stmt ::= declaration_type_spec ((',' attr_spec)* '::')? entity_decl_list eol {pin=1}
// R502
attr_spec ::= access_spec | allocatable | asynchronous | (codimension '[' coarray_spec ']')
             | contiguous | (dimension '(' array_spec ')') | external
             | (intent '(' intent_spec ')') | intrinsic | language_binding_spec
             | optional | parameter | pointer | protected | save | target | value | volatile
// R503
private entity_decl_list ::= entity_decl (',' entity_decl)*
entity_decl ::= identifier ('(' array_spec ')')? ('[' coarray_spec ']')?
                ('*' char_length)? initialization?
// R507
private access_spec ::= (public | private)
// R508
language_binding_spec ::= bind '(' (',' fname '=' expr)? ')'
// R509
private coarray_spec ::= deferred_coshape_spec_list// | explicit_coshape_spec
// R510
deferred_coshape_spec_list ::= ':' (',' ':')*
// R515
private array_spec ::= explicit_shape_spec_list | assumed_shape_spec_list
                | deferred_shape_spec_list //| assumed_size_spec | implied_shape_spec_list
// R516
private explicit_shape_spec_list ::= explicit_shape_spec (',' explicit_shape_spec)*
explicit_shape_spec ::= (expr ':')? expr
// R519
private assumed_shape_spec_list ::= assumed_shape_spec (',' assumed_shape_spec)*
assumed_shape_spec ::= (expr)? ':'
// R520
private deferred_shape_spec_list ::= deferred_shape_spec (',' deferred_shape_spec)*
deferred_shape_spec ::= (expr)? ':'

// R523
private intent_spec ::= in | out | inout
// R442
char_length ::= ('(' type_param_value ')') | integer_literal
// R548
parameter_stmt ::= parameter '(' named_constant_def_list ')' {pin=1}
// R549
private named_constant_def_list ::= named_constant_def (',' named_constant_def)*
named_constant_def ::= identifier '=' expr
// R560
implicit_stmt ::= implicit (implisit_spec_list | none) { pin = 1}
// R561
private implisit_spec_list ::= implicit_spec (',' implicit_spec)*
implicit_spec ::= declaration_type_spec '(' letter_spec_list ')'
// R562
private letter_spec_list ::= letter_spec (',' letter_spec)*
letter_spec ::= id ('-' id)
// Clause 6
// R602
private variable ::= designator | expr

// Clause 7
// R701
expr ::= def_binary_operator_expr
       | equiv_expr
       | or_expr
       | and_expr
       | not_expr
       | rel_expr
       | concat_expr
       | add_expr_group
       | mult_expr
       | power_expr
       | def_unary_operator_expr
       | primary

private add_expr_group ::= add_expr | unary_add_expr
def_binary_operator_expr ::= expr defined_binary_op expr
defined_binary_op ::= defoperator
equiv_expr  ::= expr ('.eqv.' | '.neqv.') expr
or_expr     ::= expr '.or.' expr
and_expr    ::= expr '.and.' expr
not_expr    ::= '.not.' expr
rel_expr    ::= expr rel_op expr
private rel_op ::= '.eq.' | '.ne.' | '.lt.' | '.le.' | '.gt.' | '.ge.'
                 | '=='   | '/='   | '<'    | '<='   | '>'    | '>='
concat_expr ::= expr '//' expr
add_expr    ::= expr ('+' | '-') expr
unary_add_expr ::= ('+' | '-') expr
mult_expr   ::= expr ('*' | '/') expr
power_expr  ::= expr '**' expr { rightAssociative=true } { extends=expr }
def_unary_operator_expr ::= defined_unary_op expr
private defined_unary_op ::= defoperator
private primary ::= constant | designator | paren
paren ::= '(' expr ')' { pin=1}

designator ::= identifier
constant ::= integer_literal | floating_point_literal | double_precision_literal
           | string_literal | logical_constant
logical_constant ::= '.true.' | '.false.'
// R732
assignment_stmt ::= variable '=' expr {pin = 2}

// R752
forall_header ::= '(' (type_spec '::')? forall_triplet_spec+ (expr)? ')' {pin=1}
// R753 + 754 + 755
forall_triplet_spec ::= identifier '=' expr ':' expr (':' expr)? {pin=2}


// Clause 8
// R801 + R208 we parse statements in any order while the standard has some restrictions. We'll check them in code revisions
block ::= (eol | execution_part_construct)*

// R813
private do_construct ::= block_do_construct // | nonblock_do_constract
// R814  + 820
block_do_construct ::= do_stmt block end_do { pin = 1}
// R815 + 818 + 819
private do_stmt ::= label_do_stmt | nonlabel_do_stmt
// R816
label_do_stmt ::= (identifier ':')? do label loop_control? eol { pin = 3 }
// R817
nonlabel_do_stmt ::= (identifier ':')? do loop_control? eol { pin = 2 }
// R818
loop_control ::= id_loop_stmt | while_loop_stmt | concurrent_loop_stmt
private id_loop_stmt ::= variable '=' expr ',' expr (',' expr)? {pin=1}
private while_loop_stmt ::= while '(' expr ')' {pin=1}
private concurrent_loop_stmt ::= concurrent forall_header {pin = 1}
// R821 + 854
private end_do ::= end_do_stmt //| continue at the end of a loop is f77 specific feature
// R822
end_do_stmt ::= (end do | enddo) identifier? { pin = 1}
// R832
if_construct ::= if_then_stmt block (else_if_stmt block)* (else_stmt block)? end_if_stmt {pin = 1}

// R833
if_then_stmt ::= (identifier ':')? if '(' expr ')' then eol {pin=6}
// R834
else_if_stmt ::= ((else if)|elseif) '(' expr ')' then identifier? eol {pin=1}
// R835
else_stmt ::= else identifier? eol {pin=1}
// R836
end_if_stmt ::= ((end if)|endif) identifier? {pin=1}
// R837
if_stmt ::= if '(' expr ')' action_stmt {pin=5}

// R854
continue_stmt ::= continue

// Clause 9
// R901
io_unit ::= '*' | variable | expr
// R902, R903 are trivial
// R904
open_stmt ::= open '(' connect_spec_list ')' {pin = 1}
// R905
private connect_spec_list ::= connect_spec (',' connect_spec)*
connect_spec ::= ((unit '=')? expr)       | (access '=' expr)       | (action '=' expr)
                | (asynchronous '=' expr) | (blank '=' expr)        | (decimal '=' expr)
                | (delim '=' expr)        | (encoding '=' expr)     | (err '=' label)
                | (file '=' expr)         | (form '=' expr)         | (iomsg '=' variable)
                | (iostat '=' variable)   | (newunit '=' variable)  | (pad '=' expr)
                | (position '=' expr)     | (recl '=' expr)         | (round '=' expr)
                | (sign '=' expr)         | (status '=' expr)
// R906, R907 are trivial
// R908
close_stmt ::= close '(' close_spec_list ')' {pin = 1}
// R909
private close_spec_list ::= close_spec (',' close_spec)*
close_spec ::= ((unit '=')? expr) | (iostat '=' variable) | (err '=' label) | (status '=' expr)
// R910
read_stmt ::= read (io_control_read | format_read) {pin = 1}
private io_control_read ::= '(' io_control_spec_list ')' input_item_list? { pin = 1}
private format_read ::= format (',' input_item_list)?
// R911
write_stmt ::= write '(' io_control_spec_list ')' output_item_list? { pin= 1 }
// R912
print_stmt ::= print format (',' output_item_list)? { pin = 1 }
// R913
private io_control_spec_list ::= io_control_spec (',' io_control_spec)*
io_control_spec ::= ((unit '=')? io_unit) | ((fmt '=')? format)      | ((nml '=')? identifier)
                   | (advance '=' expr)   | (asynchronous '=' expr)  | (blank '=' expr)
                   | (decimal '=' expr)   | (delim '=' expr)         | (end '=' label)
                   | (eor '=' label)      | (err '=' label)          | (id '=' variable)
                   | (iomsg '=' variable) | (iostat '=' variable)    | (pad '=' expr)
                   | (pos '=' expr)       | (rec '=' expr)           | (round '=' expr)
                   | (sign '=' expr)      | (size '=' variable)
// R914 is trivial
// R915
private format ::= '*' | label | expr
// R916
private input_item_list ::= input_item (',' input_item)*
input_item ::= variable | io_implied_do
// R917
private output_item_list ::= output_item (',' output_item)*
output_item ::= expr | io_implied_do
// R918 + R920
io_implied_do ::= '(' io_implied_do_object_list ',' id_loop_stmt ')' { pin = 1}
// R919
private io_implied_do_object_list ::= io_implied_do_object (',' io_implied_do_object)*
io_implied_do_object ::= input_item | output_item
// R921
dtv_type_spec ::= (type | fclass) '(' derived_type_spec ')' { pin =1 }
// R922
wait_stmt ::= wait '(' wait_spec_list ')' { pin =1 }
// R923
private wait_spec_list ::= wait_spec (',' wait_spec)*
wait_spec ::= ((unit '=')? expr) | (end '=' label)      | (eor '=' label)       | (err '=' label)
            | (id '=' expr)      | (iomsg '=' variable) | (iostat '=' variable)
// R924
backspace_stmt ::= backspace (('(' position_and_flush_spec_list ')') | expr ) { pin = 1 }
// R925
endfile_stmt ::= endfile (('(' position_and_flush_spec_list ')') | expr) { pin = 1 }
// R926
rewind_stmt ::= rewind (('(' position_and_flush_spec_list ')') | expr) { pin = 1}
// R927 + R929
private position_and_flush_spec_list ::= position_and_flush_spec (',' position_and_flush_spec)*
position_and_flush_spec ::= ((unit '=')? expr) | (iomsg '=' variable) | (iostat '=' variable) | (err '=' label)
// R928
flush_stmt ::= flush (('(' position_and_flush_spec_list ')') | expr) { pin = 1}
// R930
inquire_stmt ::= inquire (inquire_with_iolength | ('(' inquire_spec_list ')'))  { pin = 1}
private inquire_with_iolength ::= '(' iolength '=' variable ')' output_item_list { pin = 2}
// R931
private inquire_spec_list ::= inquire_spec (',' inquire_spec)*
inquire_spec ::=  ((unit '=')? expr)          | (file '=' expr)             | (access '=' variable)
                  | (action '=' variable)     | (asynchronous '=' variable) | (blank '=' variable)
                  | (decimal '=' variable)    | (delim '=' variable)        | (direct '=' variable)
                  | (encoding '=' variable)   | (err '=' label)             | (exist '=' variable)
                  | (form '=' variable)       | (formatted '=' variable)    | (id '=' expr)
                  | (iomsg '=' variable)      | (iostat '=' variable)       | (fname '=' variable)
                  | (named '=' variable)      | (nextrec '=' variable)      | (number '=' variable)
                  | (opened '=' variable)     | (pad '=' variable)          | (pending '=' variable)
                  | (pos '=' variable)        | (position '=' expr)         | (read '=' variable)
                  | (readwrite '=' variable)  | (recl '=' variable)         | (round '=' variable)
                  | (sequential '=' variable) | (sign '=' variable)         | (size '=' variable)
                  | (stream '=' variable)     | (unformatted '=' variable)  | (write '=' variable)

// Clause 11
// R1101
main_program ::= program_stmt? specification_part block
            /*internal_subprogram_part*/ end_program_stmt {pin=1}

// R1102 +
program_stmt ::= program identifier eol {pin=1}

// R1103 +
end_program_stmt ::=  (endprogram identifier? | end (program identifier?)?) eol? {pin = 1}

// R1109
use_stmt ::= use (use_stmt_rename | use_stmt_only) {pin = 1}
private use_stmt_rename ::= ((',' module_nature)? '::')? identifier (',' rename_list)
private use_stmt_only ::= ((',' module_nature)? '::')? identifier ',' only ':' (only_list) { pin = 4}
// R1110
private module_nature ::= intrinsic | non_intrinsic
// R1111
private rename_list ::= rename_stmt (',' rename_stmt)*
rename_stmt ::= (identifier '=>' identifier)
               |(operator '(' defoperator ')' '=>' operator '(' defoperator ')')
// R1112
private only_list ::= only_stmt (',' only_stmt)*
only_stmt ::= generic_spec | identifier | rename_stmt

// Clause 12
// R1207
generic_spec ::= identifier | (operator '(' defoperator ')')
              | assignment '(' '=' ')' | defined_io_generic_spec
// R1208
defined_io_generic_spec ::= read '(' (formatted | unformatted) ')'
                           | write '(' (formatted | unformatted) ')'
// R1209
import_stmt ::= import ('::'? name_list) { pin =1 }
private name_list ::= identifier (',' identifier)*


// That's a cap. Must be removed in the final version
cap ::= line_comment //| white_space

{
  parserClass='org.jetbrains.fortran.lang.parser.FortranParser'
  implements='org.jetbrains.fortran.lang.psi.FortranCompositeElement'
  extends='org.jetbrains.fortran.lang.psi.impl.FortranCompositeElementImpl'

  elementTypeHolderClass='org.jetbrains.fortran.lang.FortranTypes'
  elementTypeClass='org.jetbrains.fortran.lang.psi.FortranCompositeElementType'
  tokenTypeClass='org.jetbrains.fortran.lang.psi.FortranTokenType'

  psiClassPrefix='Fortran'
  psiImplClassSuffix='Impl'
  psiPackage='org.jetbrains.fortran.lang.psi'
  psiImplPackage='org.jetbrains.fortran.lang.psi.impl'

//  parserUtilClass='org.rust.lang.core.parser.RustParserUtil'
//  psiImplUtilClass = ''
//  psiTreeUtilClass = ''
  generateTokenAccessors=true
  tokens=[
    EQ        = '='
    EQEQ      = 'regexp:==|.eq.'
    NEQ       = 'regexp:/=|.neq.'
    COLON     = ':'
    COLONCOLON = '::'
    PLUS      = '+'
    MINUS     = '-'
    MUL       = '*'
    POWER     = '**'
    DIV       = '/'
    DIVDIV    = '//'
    LPAR      = '('
    RPAR      = ')'
    LBRACKET  = '['
    RBRACKET  = ']'
    ARRAYLBR  = '(/'
    ARRAYRBR  = '/)'
    COMMA     = ','
    DOT       = '.'
    DOLLAR    = '$'
    PERC      = '%'
    AMP       = '&'
  //  SEMICOLON = ';'
    LT        = 'regexp:<|.lt.'
    LE        = 'regexp:<=|.le.'
    GT        = 'regexp:>|.gt.'
    GE        = 'regexp:>=|.ge.'
    QUEST     = '?'

    LOGICAL_EQ  = '.eqv.'
    LOGICAL_NEQ = '.neqv.'
    AND         = '.and.'
    OR          = '.or.'
    NOT         = '.not.'

    TRUE  = '.true.'
    FALSE = '.false.'

    POINTER_ASSMNT = '=>'
  ]

  extends(".*expr")=expr
  consumeTokenMethod(".*_expr|expr")="consumeTokenFast"
}

file ::= program

// Clause 0
// System parts needed for this implementation
// format is *, label or expression, matches all possibilities
private standard_command_parameters_spec ::= !')' ((identifier | end | namekwd) '=')? format {
  pin = 1
  recoverWhile = parameter_spec_recover
}
private parameter_spec_recover ::= !(')' | ',')
private name_list ::= identifier (',' identifier)*
// Clause 1 (ready)
// R101 is implemented for every list separately
// R102 and R103 are trivial

// Clause 2
// R201
private program ::= (eol | program_unit)*
// R202
private program_unit ::= !<<eof>> (external_subprogram | module | submodule | block_data | main_program) {
  pin = 1
  recoverWhile = program_unit_recover
}
private program_unit_recover ::= !(eol | end_unit_keys)
private end_unit_keys ::= end | endprogram | endmodule | endfunction | endsubroutine | endsubmodule
// R203
private external_subprogram ::= function_subprogram | subroutine_subprogram
// R204
specification_part ::= (eol | use_stmt)* (eol | import_stmt)* implicit_part? (eol | declaration_construct)*
// R205
implicit_part ::= (eol | implicit_part_stmt)* implicit_stmt eol
// R206
implicit_part_stmt ::= label? (implicit_stmt | parameter_stmt | entry_stmt | format_stmt)
// R207
declaration_construct ::= label? (derived_type_def | entry_stmt | format_stmt | enum_def
                        | interface_block | parameter_stmt | procedure_declaration_stmt
                        | other_specification_stmt | type_declaration_stmt | stmt_function_stmt)

// R208 is in R801
// R209
private execution_part_construct ::= !(label? end_block_keys) (executable_construct | entry_stmt | format_stmt) {
  pin=1
  recoverWhile=block_recover
}//   | data-stmt
private block_recover ::= !(eol | end_block_keys) // recover doesn't eat what it is not necessary to eat
private end_block_keys ::= end | endprogram | endprocedure | endsubroutine | endfunction | endif | enddo | else
                    | elseif | endblock | endcritical | endassociate | case | endselect | contains
// R210
internal_subprogram_part ::= contains_stmt (eol | internal_subprogram)* { pin = 1 }
// R211
internal_subprogram ::= !(label? (end_unit_keys | endprocedure)) (function_subprogram | subroutine_subprogram) {
  pin = 1
  recoverWhile=internal_subprogram_recover
}
private internal_subprogram_recover ::= !(eol | end | endfunction | endsubprogram | endprocedure)
// R212
other_specification_stmt ::= /* access_stmt
                           |  allocatable-stmt
                           |  asynchronous-stmt
                           |  bind-stmt
                           |  codimension-stmt
                           |  common-stmt
                           |  data-stmt
                           |  dimension-stmt
                           |  equivalence-stmt
                           |*/  external_stmt
                         /*  |  intent-stmt*/
                           |  intrinsic_stmt/*
                           |  namelist-stmt
                           |  optional-stmt
                           |  pointer-stmt
                           |  protected-stmt
                           |  save-stmt
                           |  target-stmt
                           |  volatile-stmt
                           |  value-stmt*/
// R213
private executable_construct ::= action_stmt   | associate_construct | block_construct  | case_construct
                       | critical_construct    | do_construct        | forall_construct | if_construct
                       | select_type_construct | where_construct
// R214
private action_stmt ::= /*allocate-stmt
                |*/ assignment_stmt
                | backspace_stmt
                | call_stmt
                | close_stmt
                | continue_stmt
                | cycle_stmt/*
                | deallocate-stmt*/
                | endfile_stmt
                | error_stop_stmt
                | exit_stmt
                | flush_stmt
                | forall_stmt
                | goto_stmt
                | if_stmt
                | inquire_stmt
                | lock_stmt/*
                | nullify-stmt*/
                | open_stmt
                | pointer_assignment_stmt
                | print_stmt
                | read_stmt
                | return_stmt
                | rewind_stmt
                | stop_stmt
                | sync_all_stmt
                | sync_images_stmt
                | sync_memory_stmt
                | unlock_stmt
                | wait_stmt
                | where_stmt
                | write_stmt
                | arithmetic_if_stmt
                | computed_goto_stmt
// R215 is trivial

// Clause 3 (probably ready)
// R301, R302, R303 are implemented is lexer 'name' is replaced by 'identifier'
// R304, R305 are implemented in Clause 7
// R306, R307, R308 are trivial
// R309, R310, R311 are excess
// R312
label ::= integer_literal

// Clause 4
// R401
private type_param_value ::= '*' | ':' | expr
// R402
private type_spec ::= intrinsic_type_spec | derived_type_spec
// R403
private declaration_type_spec ::= intrinsic_type_spec | (type '(' (intrinsic_type_spec | derived_type_spec)')')
                                | (classkwd '(' (derived_type_spec | '*') ')')
// R404
intrinsic_type_spec ::= ((integer | real | complex | logical) (kind_selector)?) | (double precision) | (character (char_selector)?)
// R405
kind_selector ::= '(' (kind '=')? expr ')' {pin = 2}
// R406
signed_int_literal ::= ('+' | '-')? integer_literal
// R407 - 411 are trivial or implemented in lexer
// R412
signed_real_literal ::= ('+' | '-') (floating_point_literal | double_precision_literal)
// R412 - 416 are implemented in lexer
// R417
complex_literal ::= '(' ri_part ',' ri_part ')'
// R418 - 419
private ri_part ::= signed_int_literal | signed_real_literal | identifier
// R420
char_selector ::= length_selector | ('(' len '=' type_param_value ',' kind '=' expr ')')
                 | ('(' type_param_value ',' (kind '=')? expr ')')
                 | ('(' kind '=' expr (',' len '=' type_param_value)? ')')
// R421
length_selector ::= ('(' (len '=')? type_param_value ')') | ('*' char_length (',')?)
// R422
char_length ::= ('(' type_param_value ')') | integer_literal
// R423 - 424 are implemented in lexer
// R425
derived_type_def ::= derived_type_stmt type_param_def_stmt* private_or_sequence* component_part
                     type_bound_procedure_part? end_type_stmt { pin = 1 }
// R426
derived_type_stmt ::= label? type ((',' type_attr_spec_list)? '::')? identifier ('(' name_list ')')? eol { pin = 2 }
// R427
private type_attr_spec_list ::= type_attr_spec (',' type_attr_spec)*
type_attr_spec ::= abstract | access_spec | bindckwd | (extends '(' identifier ')')
// R428
private private_or_sequence ::= label? (private | sequence) eol { pin = 2 }
// R429
end_type_stmt ::= label? ((end type) | endtype) identifier? { pin = 2 }
// R430 is trivial
// R431
type_param_def_stmt ::= integer (kind_selector)?','type_param_attr_spec '::' type_param_decl_list
// R432
private type_param_decl_list ::= type_param_decl (',' type_param_decl)
type_param_decl ::= identifier ('=' expr)?
// R433
type_param_attr_spec ::= kind | len
// R434
component_part ::= (eol | component_def_stmt)*
// R435
component_def_stmt ::= !(label? (type_end_keys | contains)) label? (data_component_def_stmt | proc_component_def_stmt) {
 pin = 1
 recoverWhile = component_def_stmt_recover }
private component_def_stmt_recover ::= !(eol | type_end_keys | contains)
// R436
data_component_def_stmt ::= declaration_type_spec ((',' component_attr_spec_list)? '::')? component_decl_list
// R437
private component_attr_spec_list ::= component_attr_spec (',' component_attr_spec)*
component_attr_spec ::= access_spec | allocatable | (codimension '[' coarray_spec ']')
                       | contiguous | (dimension '(' component_array_spec ')') | pointer
// R438
private component_decl_list ::= component_decl (',' component_decl)*
component_decl ::= identifier ('(' component_array_spec ')')? ('[' coarray_spec ']')?
                   ('*' char_length)? (initialization)?
// R439
private component_array_spec ::= explicit_shape_spec_list | deferred_shape_spec_list
// R440
proc_component_def_stmt ::= procedure '(' proc_interface? ')'',' proc_component_attr_spec_list '::' proc_decl_list
// R441
private proc_component_attr_spec_list ::= proc_component_attr_spec (',' proc_component_attr_spec)*
proc_component_attr_spec ::= pointer | (pass ('(' identifier ')')?) | nopass | access_spec
// R442 is the same as R505
// R443 - 444 are trivial
// R445
type_bound_procedure_part ::= contains_stmt private_stmt? (eol | type_bound_proc_binding)*
// R446
private_stmt ::= label? private eol { pin = 2 }
// R447
private type_bound_proc_binding ::= !(label? type_end_keys) (type_bound_procedure_stmt | type_bound_generic_stmt | final_procedure_stmt) {
 pin = 1
 recoverWhile = type_proc_recover
}
private type_proc_recover ::= !(eol | type_end_keys)
private type_end_keys ::= (end | endtype)
// R448
type_bound_procedure_stmt ::= procedure (type_bound_procedure_stmt_part1 | type_bound_procedure_stmt_part2 ) { pin = 1 }
private type_bound_procedure_stmt_part1 ::= '(' identifier ')' ',' binding_attr_list '::' name_list { pin = 1 }
private type_bound_procedure_stmt_part2 ::= ((',' binding_attr_list)? '::')? type_bound_proc_decl_list
// R449
private type_bound_proc_decl_list ::= type_bound_proc_decl (',' type_bound_proc_decl)*
type_bound_proc_decl ::= identifier ('=>' identifier)?
// R450
type_bound_generic_stmt ::= generic (',' access_spec)? '::' generic_spec '=>' name_list { pin = 1}
// R451
private binding_attr_list ::= binding_attr (',' binding_attr)*
binding_attr ::= (pass ('(' identifier ')')?) | nopass | non_overridable | deferred | access_spec
// R452
final_procedure_stmt ::= final '::' name_list { pin = 1 }
// R453
derived_type_spec ::= identifier ('(' type_param_spec_list ')')?
// R454
private type_param_spec_list ::= type_param_spec (',' type_param_spec)*
type_param_spec ::= (identifier '=')? type_param_value
// R455 is in clause 7
// R456
private component_spec_list ::= component_spec (',' component_spec)*
component_spec ::= (identifier '=') component_data_source
// R457
component_data_source ::= expr /*| variable*/ | proc_target
// R458
enum_def ::= enum_def_stmt (eol | enumerator_def_stmt)+ end_enum_stmt { pin = 1 }
// R459
enum_def_stmt ::= label? enum ',' bindckwd eol { pin = 4 }
// R460
enumerator_def_stmt ::= !(label? end_enum_keys) label? enumeratorkwd ('::')? enumerator_list {
  pin = 1
  recoverWhile = enum_recover
}
private end_enum_keys ::= (end enum) | endenum
private enum_recover ::= !(eol | end_enum_keys)
// R461
private enumerator_list ::= enumerator (',' enumerator)*
enumerator ::= identifier ('=' expr)?
// R462
end_enum_stmt ::= label? ((end enum) | endenum) { pin = 2 }
// R463
boz_literal ::= binary_literal | octal_literal | hex_literal
// R464 - R467 are implemented in lexer
// R468 is in clause 7
// R469
ac_spec ::= ((type_spec '::')? ac_value_list ) | (type_spec '::')
// R470 - 471 are trivial
// R472
private ac_value_list ::= ac_value (',' ac_value)*
ac_value ::= expr | ac_implied_do
// R473
ac_implied_do ::= '('ac_value_list ',' id_loop_stmt ')'
// R474 - 475 are trivial

// Clause 5
// R501
type_declaration_stmt ::= declaration_type_spec ((',' attr_spec)* '::')? entity_decl_list eol {pin=1}
// R502
attr_spec ::= access_spec | allocatable | asynchronous | (codimension '[' coarray_spec ']')
             | contiguous | (dimension '(' array_spec ')') | external
             | (intent '(' intent_spec ')') | intrinsic | language_binding_spec
             | optional | parameter | pointer | protected | save | target | value | volatile
// R503
private entity_decl_list ::= entity_decl (',' entity_decl)*
entity_decl ::= identifier ('(' array_spec ')')? ('[' coarray_spec ']')?
                ('*' char_length)? initialization?
// R505
private initialization ::= ('=' expr) | ('=>' designator) | ('=>' function_reference)
// R507
private access_spec ::= (public | private)
// R508
language_binding_spec ::= bind '(' (',' namekwd '=' expr)? ')'
// R509
private coarray_spec ::= deferred_coshape_spec_list// | explicit_coshape_spec
// R510
deferred_coshape_spec_list ::= ':' (',' ':')*
// R515
private array_spec ::= explicit_shape_spec_list | assumed_shape_spec_list
                | deferred_shape_spec_list //| assumed_size_spec | implied_shape_spec_list
// R516
private explicit_shape_spec_list ::= explicit_shape_spec (',' explicit_shape_spec)*
explicit_shape_spec ::= (expr ':')? expr
// R519
private assumed_shape_spec_list ::= assumed_shape_spec (',' assumed_shape_spec)*
assumed_shape_spec ::= (expr)? ':'
// R520
private deferred_shape_spec_list ::= deferred_shape_spec (',' deferred_shape_spec)*
deferred_shape_spec ::= (expr)? ':'

// R523
private intent_spec ::= in | out | inout

// R548
parameter_stmt ::= parameter '(' named_constant_def_list ')' {pin=1}
// R549
private named_constant_def_list ::= named_constant_def (',' named_constant_def)*
named_constant_def ::= identifier '=' expr
// R560
implicit_stmt ::= label? implicit (implisit_spec_list | none) { pin = 2}
// R561
private implisit_spec_list ::= implicit_spec (',' implicit_spec)*
implicit_spec ::= declaration_type_spec '(' letter_spec_list ')'
// R562
private letter_spec_list ::= letter_spec (',' letter_spec)*
letter_spec ::= identifier ('-' identifier)
// Clause 6
// R601 is implemented in clause 7
// R602
private variable ::= designator | expr

// Clause 7
// expressions in bnf grammar must be defined in a special order
// R701 - R722 + R304 + R305 + R601
expr ::= def_binary_operator_expr
       | equiv_expr
       | or_expr
       | and_expr
       | not_expr
       | rel_expr
       | concat_expr
       | add_expr_group
       | mult_expr
       | power_expr
       | def_unary_operator_expr
       | primary

private add_expr_group ::= add_expr | unary_add_expr
def_binary_operator_expr ::= expr defined_binary_op expr
defined_binary_op ::= defoperator
equiv_expr  ::= expr ('.eqv.' | '.neqv.') expr
or_expr     ::= expr '.or.' expr
and_expr    ::= expr '.and.' expr
not_expr    ::= '.not.' expr
rel_expr    ::= expr rel_op expr
private rel_op ::= '.eq.' | '.ne.' | '.lt.' | '.le.' | '.gt.' | '.ge.'
                 | '=='   | '/='   | '<'    | '<='   | '>'    | '>='
concat_expr ::= expr '//' expr
add_expr    ::= expr ('+' | '-') expr
unary_add_expr ::= ('+' | '-') expr
mult_expr   ::= expr ('*' | '/') expr
power_expr  ::= expr '**' expr { rightAssociative=true } { extends=expr }
def_unary_operator_expr ::= defined_unary_op expr
private defined_unary_op ::= defoperator
private primary ::= constant | designator | structure_constructor | array_constructor | paren
paren ::= '(' expr ')'
// R455
structure_constructor ::= derived_type_spec '(' component_spec_list ')'
// R468
array_constructor ::= ('(/' ac_spec '/)') | ('[' ac_spec ']')
// R601
designator ::= identifier
// R304, R305 modified
constant ::= integer_literal | floating_point_literal | double_precision_literal
           | complex_literal | logical_literal | string_literal | boz_literal
logical_literal ::= true | false

// R724 - 731 are trivial

// R732
assignment_stmt ::=  designator '=' expr {pin = 2} // it was a variable here in the standard but we don't want to match an expression
// R733
pointer_assignment_stmt ::= pointer_a_with_data_pointer | pointer_a_with_proc_pointer
private pointer_a_with_data_pointer ::= data_pointer_object (('(' bounds_remapping_list ')')
                                | ('(' bounds_spec_list')')?) '=>' variable { pin = 3 }
private pointer_a_with_proc_pointer ::= proc_pointer_object '=>' proc_target { pin = 2 }
// R734
data_pointer_object ::= (variable '%' identifier) | identifier
// R735
private bounds_spec_list ::= bounds_spec (',' bounds_spec)*
bounds_spec ::= expr ':'
// R736
private bounds_remapping_list ::= bounds_remapping (',' bounds_remapping)*
bounds_remapping ::= expr ':' expr
// R737 is trivial
// R738 + R739
proc_pointer_object ::= (variable '%' identifier) | identifier
// R740
proc_target ::= expr | (variable '%' identifier) | identifier // last two options may be parsed as expr. Need to check later
// R741
where_stmt ::= where '(' expr ')' assignment_stmt { pin = 5}
// R742
where_construct ::= where_construct_stmt (label? (eol | where_body_construct))* (masked_elsewhere_stmt (label? (eol | where_body_construct))*)*
                    (elsewhere_stmt (label? (eol | where_body_construct))*)? end_where_stmt { pin = 1 }
// R743
where_construct_stmt ::= (identifier ':')? where '(' expr ')' eol { pin = 6 }
// R744
private where_body_construct ::= !(label? end_where_keys) (assignment_stmt | where_stmt | where_construct) {
  pin = 1
  recoverWhile = where_recover
}
private where_recover ::= !(eol | end_where_keys)
private end_where_keys ::= end | else | elsewhere | endwhere
// R745, R746 are trivial
// R747
masked_elsewhere_stmt ::= label? ((else where) | elsewhere) '(' expr ')' identifier? eol { pin = 3 }
// R748
elsewhere_stmt ::= label? ((else where) | elsewhere) identifier? eol { pin = 3 }
// R749
end_where_stmt ::= label? ((end where) | endwhere) identifier? { pin = 2 }
// R750
forall_construct ::= forall_construct_stmt (label? (eol | forall_body_construct))* end_forall_stmt { pin = 1 }
// R751
forall_construct_stmt ::= (identifier ':')? forall forall_header eol { pin = 4 }
// R752
forall_header ::= '(' (type_spec '::')? forall_triplet_spec+ (expr)? ')' {pin=1}
// R753 + 754 + 755
forall_triplet_spec ::= identifier '=' expr ':' expr (':' expr)? {pin=2}
// R756
private forall_body_construct ::= !(label? end_forall_keys) (forall_assignment_stmt | where_construct | where_stmt
                        | forall_construct | forall_stmt) {
  pin = 1
  recoverWhile = forall_recover
}
private forall_recover ::= !(eol | end_forall_keys)
private end_forall_keys ::= end | endforall
// R757
private forall_assignment_stmt ::= assignment_stmt | pointer_assignment_stmt
// R758
end_forall_stmt ::= label? ((end forall) | endforall) identifier? { pin = 2 }
// R759
forall_stmt ::= forall forall_header forall_assignment_stmt { pin = 3 }


// Clause 8
// R801 + R208 we parse statements in any order while the standard has some restrictions. We'll check them in code revisions
block ::= (label? (eol | execution_part_construct))*
// R802
associate_construct ::= associate_stmt block end_associate_stmt { pin = 1 }
// R803
associate_stmt ::= (identifier ':')? associate association_list eol { pin = 2 }
// R804
private association_list ::= association (',' association)*
association ::= identifier '=>' selector { pin = 2 }
// R805
private selector ::= expr | variable
// R806
end_associate_stmt ::= label? ((end associate) | endassociate) (identifier)? { pin = 2 }
// R807
block_construct ::= block_stmt (specification_part)? block end_block_stmt { pin = 1 }
// R808
block_stmt ::= (identifier ':')? blockkwd eol { pin = 3 }
// R809
end_block_stmt ::= label? ((end blockkwd) | endblock) (identifier)? {pin = 2 }
// R810
critical_construct ::= critical_stmt block end_critical_stmt
// R811
critical_stmt ::= (identifier ':')? critical eol { pin = 2 }
// R812
end_critical_stmt ::= label? ((end critical) | endcritical) (identifier)? { pin = 2 }
// R813
private do_construct ::= block_do_construct  | nonblock_do_constract
// R814
block_do_construct ::= do_stmt block end_do { pin = 1}
// R815
private do_stmt ::= label_do_stmt | nonlabel_do_stmt
// R816
label_do_stmt ::= (identifier ':')? do label loop_control? eol { pin = 3 }
// R817
nonlabel_do_stmt ::= (identifier ':')? do loop_control? eol { pin = 2 }
// R818
loop_control ::= id_loop_stmt | while_loop_stmt | concurrent_loop_stmt
private id_loop_stmt ::= variable '=' expr ',' expr (',' expr)? {pin=1}
private while_loop_stmt ::= while '(' expr ')' {pin=1}
private concurrent_loop_stmt ::= concurrent forall_header {pin = 1}
// R819, R820 are trivial
// R821
private end_do ::= end_do_stmt //| continue at the end of a loop is f77 specific feature
// R822
end_do_stmt ::= label? (end do | enddo) identifier? { pin = 2}
// R823 deprecated
private nonblock_do_constract ::= action_term_do_construct | outer_shared_do_construct
// R824 deprecated
action_term_do_construct ::= label_do_stmt block do_term_action_stmt { pin = 1 }
// R825 is trivial
// R826 deprecated
do_term_action_stmt ::= action_stmt // must contain label, don't know how to parse it, maybe tree analyze help later
// R827 deprecated
outer_shared_do_construct ::= label_do_stmt block shared_term_do_construct { pin = 3 }
// R828 deprecated
private shared_term_do_construct ::= outer_shared_do_construct | inner_shared_do_construct
// R829 deprecated
inner_shared_do_construct ::= label_do_stmt block do_term_shared_stmt  { pin = 3 }
// R830 deprecated
do_term_shared_stmt ::= action_stmt // must contain label, don't know how to parse it, maybe tree analyze help later
// R831
cycle_stmt ::= cycle (identifier)? { pin = 1 }
// R832
if_construct ::= if_then_stmt block (else_if_stmt block)* (else_stmt block)? end_if_stmt { pin = 1 }
// R833
if_then_stmt ::= (identifier ':')? if '(' expr ')' then eol {pin=6}
// R834
else_if_stmt ::= label? ((else if)|elseif) '(' expr ')' then identifier? eol { pin = 2 }
// R835
else_stmt ::= label? else identifier? eol { pin = 2 }
// R836
end_if_stmt ::= label? ((end if)|endif) identifier? { pin = 2 }
// R837
if_stmt ::= if '(' expr ')' action_stmt {pin=5}
// R838
case_construct ::= select_case_stmt (case_stmt block)* end_select_stmt { pin = 1 }
// R839
select_case_stmt ::= (identifier ':')? select case '(' expr ')' eol { pin = 3 }
// R840
case_stmt ::= label? case case_selector (identifier)? eol { pin = 2 }
// R841
end_select_stmt ::= label? ((end select) | endselect ) (identifier)? { pin = 2 }
// R842 is trivial
// R843
case_selector ::= ('(' case_value_range_list ')') | default
// R844
private case_value_range_list ::= case_value_range (',' case_value_range)*
case_value_range ::= (expr ':' expr) | (expr ':') | expr | (':' expr)
// R845 is trivial
// R846
select_type_construct ::= select_type_stmt (type_guard_stmt block)* end_select_stmt { pin = 1 }
// R847
select_type_stmt ::= (identifier ':')? select type '(' (identifier '=>')? selector ')' { pin = 3 }
// R848
type_guard_stmt ::= (typeis_guard | classis_guard | classdefault_guard) identifier? { pin = 1 }
private typeis_guard ::= type is '(' type_spec ')' { pin = 1 }
private classis_guard ::= classkwd is '(' derived_type_spec ')' { pin = 2 }
private classdefault_guard ::= classkwd default { pin = 2 }
// R849 is a copy of R841
// R850
exit_stmt ::= exit (identifier)?
// R851
goto_stmt ::= ((go to) | goto) label { pin = 2 }
// R852 deprecated
computed_goto_stmt ::= ((go to) | goto) '(' label_list ')' (',')? expr { pin = 2 }
private label_list ::= label (',' label)*
// R853 deprecated
arithmetic_if_stmt ::= if '(' expr ')' label ',' label ',' label { pin = 5 }
// R854
continue_stmt ::= continue
// R855
stop_stmt ::= stop (expr)? { pin = 1 }
// R856
error_stop_stmt ::= error stop (expr)? { pin = 1 }
// R857 it trivial
// R858
sync_all_stmt ::= ((sync all) | syncall) ('(' ( sync_stat_list )? ')')? { pin = 1 }
// R859
private sync_stat_list ::= sync_stat (',' sync_stat)*
sync_stat ::= standard_command_parameters_spec
// sync_stat ::= (stat | errmsg) '=' variable { pin = 1 }
// R860
sync_images_stmt ::= ((sync images) | syncimages) '(' image_set (',' sync_stat_list)?')' { pin = 1 }
// R861
image_set ::= '*' | expr
// R862
sync_memory_stmt ::= ((sync memory) | syncmemory) ('(' (sync_stat_list)? ')')? { pin = 1 }
// R863
lock_stmt ::= lock '(' variable (',' lock_stat_list)? ')' { pin = 1 }
// R864
private lock_stat_list ::= lock_stat (',' lock_stat)*
lock_stat ::=  (identifier identifier '=' variable) | sync_stat
// lock_stat ::= (acquired lock '=' variable) | sync_stat
// R865
unlock_stmt ::= unlock '(' variable (',' sync_stat_list)? ')' { pin = 1 }
// R866 is trivial

// Clause 9 (ready)
// R901 don't need now
//io_unit ::= '*' | variable | expr
// R902, R903 are trivial
// R904
open_stmt ::= open '(' connect_spec_list ')' {pin = 1}
// R905
private connect_spec_list ::= connect_spec (',' connect_spec)*
connect_spec ::= standard_command_parameters_spec
// Thats not a real rul. But we'll check parameters names later
/*connect_spec ::= ((unit '=')? expr)       | (access '=' expr)       | (action '=' expr)
                | (asynchronous '=' expr) | (blank '=' expr)        | (decimal '=' expr)
                | (delim '=' expr)        | (encoding '=' expr)     | (err '=' label)
                | (file '=' expr)         | (form '=' expr)         | (iomsg '=' variable)
                | (iostat '=' variable)   | (newunit '=' variable)  | (pad '=' expr)
                | (position '=' expr)     | (recl '=' expr)         | (round '=' expr)
                | (sign '=' expr)         | (status '=' expr)*/
// R906, R907 are trivial
// R908
close_stmt ::= close '(' close_spec_list ')' {pin = 1}
// R909
private close_spec_list ::= close_spec (',' close_spec)*
close_spec ::= standard_command_parameters_spec
// Thats not a real rul. But we'll check parameters names later
// close_spec ::= ((unit '=')? expr) | (iostat '=' variable) | (err '=' label) | (status '=' expr)
// R910
read_stmt ::= read (io_control_read | format_read) {pin = 1}
private io_control_read ::= '(' io_control_spec_list ')' input_item_list? { pin = 1}
private format_read ::= format (',' input_item_list)?
// R911
write_stmt ::= write '(' io_control_spec_list ')' output_item_list? { pin= 1 }
// R912
print_stmt ::= print format (',' output_item_list)? { pin = 1 }
// R913
private io_control_spec_list ::= io_control_spec (',' io_control_spec)*
io_control_spec ::= standard_command_parameters_spec
// Thats not a real rul. But we'll check parameters names later
/*io_control_spec ::= ((unit '=')? io_unit) | ((fmt '=')? format)      | ((nml '=')? identifier)
                   | (advance '=' expr)   | (asynchronous '=' expr)  | (blank '=' expr)
                   | (decimal '=' expr)   | (delim '=' expr)         | (end '=' label)
                   | (eor '=' label)      | (err '=' label)          | (id '=' variable)
                   | (iomsg '=' variable) | (iostat '=' variable)    | (pad '=' expr)
                   | (pos '=' expr)       | (rec '=' expr)           | (round '=' expr)
                   | (sign '=' expr)      | (size '=' variable)*/
// R914 is trivial
// R915
private format ::= '*' /*| label*/ | expr
// we can match label when it's really an expression, but expression matches a label too
// R916
private input_item_list ::= input_item (',' input_item)*
input_item ::= variable | io_implied_do
// R917
private output_item_list ::= output_item (',' output_item)*
output_item ::= expr | io_implied_do
// R918 + R920
io_implied_do ::= '(' io_implied_do_object_list ',' id_loop_stmt ')' { pin = 1}
// R919
private io_implied_do_object_list ::= io_implied_do_object (',' io_implied_do_object)*
io_implied_do_object ::= input_item | output_item
// R921 (unused maybe)
dtv_type_spec ::= (type | classkwd) '(' derived_type_spec ')' { pin =1 }
// R922
wait_stmt ::= wait '(' wait_spec_list ')' { pin =1 }
// R923
private wait_spec_list ::= wait_spec (',' wait_spec)*
wait_spec ::= standard_command_parameters_spec
// Thats not a real rul. But we'll check parameters names later
/* wait_spec ::= ((unit '=')? expr) | (end '=' label)      | (eor '=' label)       | (err '=' label)
            | (id '=' expr)      | (iomsg '=' variable) | (iostat '=' variable)*/
// R924
backspace_stmt ::= backspace (('(' position_and_flush_spec_list ')') | expr ) { pin = 1 }
// R925
endfile_stmt ::= endfile (('(' position_and_flush_spec_list ')') | expr) { pin = 1 }
// R926
rewind_stmt ::= rewind (('(' position_and_flush_spec_list ')') | expr) { pin = 1}
// R927 + R929
private position_and_flush_spec_list ::= position_and_flush_spec (',' position_and_flush_spec)*
position_and_flush_spec ::= standard_command_parameters_spec
// Thats not a real rul. But we'll check parameters names later
// position_and_flush_spec ::= ((unit '=')? expr) | (iomsg '=' variable) | (iostat '=' variable) | (err '=' label)
// R928
flush_stmt ::= flush (('(' position_and_flush_spec_list ')') | expr) { pin = 1}
// R930
inquire_stmt ::= inquire (inquire_with_iolength | ('(' inquire_spec_list ')'))  { pin = 1}
private inquire_with_iolength ::= '(' iolength '=' variable ')' output_item_list { pin = 2}
// R931
private inquire_spec_list ::= inquire_spec (',' inquire_spec)*
inquire_spec ::= standard_command_parameters_spec
// Thats not a real rul. But we'll check parameters names later
/* inquire_sec ::= ((unit '=')? expr)          | (file '=' expr)             | (access '=' variable)
                  | (action '=' variable)     | (asynchronous '=' variable) | (blank '=' variable)
                  | (decimal '=' variable)    | (delim '=' variable)        | (direct '=' variable)
                  | (encoding '=' variable)   | (err '=' label)             | (exist '=' variable)
                  | (form '=' variable)       | (formatted '=' variable)    | (id '=' expr)
                  | (iomsg '=' variable)      | (iostat '=' variable)       | (name '=' variable)
                  | (named '=' variable)      | (nextrec '=' variable)      | (number '=' variable)
                  | (opened '=' variable)     | (pad '=' variable)          | (pending '=' variable)
                  | (pos '=' variable)        | (position '=' expr)         | (read '=' variable)
                  | (readwrite '=' variable)  | (recl '=' variable)         | (round '=' variable)
                  | (sequential '=' variable) | (sign '=' variable)         | (size '=' variable)
                  | (stream '=' variable)     | (unformatted '=' variable)  | (write '=' variable)*/

// Clause 10
// R1001
format_stmt ::= formatkwd format_specification { pin = 1}
// R1002
private format_specification ::= '(' (((format_items ',')? unlimited_format_item) | format_items?) ')' { pin = 1 }
// R1003
private format_items ::= format_item (',' format_item)*
// R1004
format_item ::= ((integer_literal)? data_edit_desc) | control_edit_desc | string_literal
               | ((integer_literal)? '(' format_items ')')
// R1005
unlimited_format_item ::= '*''(' format_items ')'
// R1006 is trivial
// R1007
data_edit_desc ::= identifier (integer_literal | floating_point_literal | (string_literal? ('(' v_list ')')?))?
// R1008-1011 are trivial
// R1012
private v_list ::= signed_int_literal (',' signed_int_literal)* // unary_add_expr (',' unary_add_expr)*
// R1013
control_edit_desc ::= position_edit_desc | (integer_literal? '/') | ':'
                  | identifier | (signed_int_literal identifier)
// R1014 is trivial
// R1015
position_edit_desc ::= (identifier integer_literal) | (integer_literal identifier)
// R1016 - R1021 are trivial or should be studied after parsing
// R1022 is unused probably


// Clause 11
// R1101
main_program ::= program_stmt? specification_part block
            internal_subprogram_part? end_program_stmt {pin=1}
// R1102 +
program_stmt ::= label? programkwd identifier eol { pin = 2 }
// R1103 +
end_program_stmt ::=  label? (endprogram identifier? | end (programkwd identifier?)?) { pin = 2 }
// R1104
module ::= module_stmt specification_part module_subprogram_part? end_module_stmt { pin = 1 }
// R1105
module_stmt ::= label? modulekwd identifier eol { pin = 2 }
// R1106
end_module_stmt ::= label? (endmodule identifier? | end (modulekwd identifier?)?) { pin = 2 }
// R1107
module_subprogram_part ::= contains_stmt (eol | module_subprogram)* { pin = 1 }
// R1108
module_subprogram ::= !(label? (end | endmodule | endsubmodule)) (function_subprogram | subroutine_subprogram | separate_module_subprogram) {
  pin = 1
  recoverWhile = module_subprogram_recover
}
private module_subprogram_recover ::= !(eol | end | endfunction | endsubprogram | endprocedure)
// R1109
use_stmt ::= label? use (use_stmt_rename | use_stmt_only) {pin = 2}
private use_stmt_rename ::= ((',' module_nature)? '::')? identifier (',' rename_list)
private use_stmt_only ::= ((',' module_nature)? '::')? identifier ',' only ':' (only_list) { pin = 4 }
// R1110
private module_nature ::= intrinsic | non_intrinsic
// R1111
private rename_list ::= rename_stmt (',' rename_stmt)*
rename_stmt ::= (identifier '=>' identifier)
               |(operator '(' defoperator ')' '=>' operator '(' defoperator ')')
// R1112
private only_list ::= only_stmt (',' only_stmt)*
only_stmt ::= generic_spec | identifier | rename_stmt
// R1113, R1114, R1115 are trivial
// R1116
submodule ::= submodule_stmt specification_part module_subprogram_part? end_submodule_stmt { pin = 1 }
// R1117
submodule_stmt ::= label? submodulekwd '(' parent_identifier ')' identifier eol { pin = 2 }
// R1118
parent_identifier ::= identifier (':' identifier)?
// R1119
end_submodule_stmt ::= label? (endsubmodule identifier? | end (submodulekwd identifier?)?)  { pin = 2 }
// R1120
block_data ::= block_data_stmt specification_part end_block_data_stmt { pin = 1 }
// R1121
block_data_stmt ::= label? (blockdata | (blockkwd data)) identifier? eol { pin = 2 }
// R1122
end_block_data_stmt ::= label? ((endblockdata identifier?)| (end (((blockkwd data) | blockdata) identifier?)?)
                      | (endblock data identifier?))  { pin = 2 }

// Clause 12
// R1201
interface_block ::= interface_stmt interface_specification* end_interface_stmt
// R1202
private interface_specification ::= interface_body | procedure_stmt
// R1203
interface_stmt ::= (abstract interface) | (interface (generic_spec)?) eol { pin = 1 }
// R1204
end_interface_stmt ::= ((end interface) | endinterface) (generic_spec)?
// R1205
interface_body ::= interface_function_body | interface_subroutine_body
private interface_function_body ::= function_stmt specification_part? end_function_stmt { pin = 1 }
private interface_subroutine_body ::= subroutine_stmt specification_part? end_subroutine_stmt { pin = 1 }
// R1206
procedure_stmt ::= (modulekwd)? procedure ('::')? name_list { pin = 2 }
// R1207
generic_spec ::= identifier | (operator '(' defoperator ')')
              | assignment '(' '=' ')' | defined_io_generic_spec
// R1208
defined_io_generic_spec ::= read '(' (formatted | unformatted) ')'
                           | write '(' (formatted | unformatted) ')'
// R1209
import_stmt ::= label? import ('::'? name_list) { pin =2}
// R1210
external_stmt ::= external ('::')? name_list { pin = 1 }
// R1211
procedure_declaration_stmt ::= procedure '(' proc_interface? ')' ((',' proc_attr_spec)* '::')? proc_decl_list { pin = 1 }
// R1212
proc_interface ::= identifier | declaration_type_spec
// R1213
proc_attr_spec ::= access_spec | language_binding_spec | (intent '(' intent_spec ')')
                  | optional | pointer | save
// R1214
private proc_decl_list ::= proc_decl (',' proc_decl)*
proc_decl ::= identifier ('=>' proc_pointer_init)?
// R1215 is trivial
// R1216
proc_pointer_init ::= function_reference | identifier
// R1217 is trivial
// R1218
intrinsic_stmt ::= intrinsic ('::')? name_list
// R1219
function_reference ::= procedure_designator '(' actual_arg_spec_list ')' { pin = 2 }
// R1220
call_stmt ::= call procedure_designator ('(' actual_arg_spec_list? ')')?
// R1221
procedure_designator ::= (data_ref '%' identifier) | (variable '%' identifier) | identifier
// R1222
private actual_arg_spec_list ::= actual_arg_spec (',' actual_arg_spec)*
actual_arg_spec ::= (identifier '=')? actual_arg
// 1223
actual_arg ::= expr | alt_return_spec // expr matches variable, procedure-name and proc-component-ref
// 1224 deprecated
alt_return_spec ::= '*' label
// R1225
prefix ::= prefix_spec+ { pin = 1 }
// R1226
prefix_spec ::= declaration_type_spec | elemental | impure | modulekwd | pure | recursive
// R1227
function_subprogram ::= function_stmt specification_part block internal_subprogram_part? end_function_stmt { pin = 1 }
// R1228
function_stmt ::= label? prefix? function identifier '(' name_list? ')' suffix? eol { pin = 3 }
// R1229 and R1230 are trivial
// R1231
suffix ::= (language_binding_spec (result '(' identifier ')')?) | (result '(' identifier ')' (language_binding_spec)?)
// R1232
end_function_stmt ::= label? ((end (function identifier?)?) | (endfunction identifier?)) { pin = 2 }
// R1233
subroutine_subprogram ::= subroutine_stmt specification_part block internal_subprogram_part? end_subroutine_stmt { pin = 1 }
// R1234
subroutine_stmt ::= label? prefix? subroutine identifier ('(' dummy_arg_list? ')' language_binding_spec? )? eol { pin = 3 }
// R1235
private dummy_arg_list ::= dummy_arg (',' dummy_arg)*
dummy_arg ::= '*' | identifier
// R1236
end_subroutine_stmt ::= label? ((end (subroutine identifier?)?) | (endsubroutine identifier?)) { pin = 2 }
// R1237
separate_module_subprogram ::= mp_subprogram_stmt specification_part block internal_subprogram_part? end_mp_subprogram_stmt { pin = 1 }
// R1238
mp_subprogram_stmt ::= label? modulekwd procedure identifier eol { pin = 3 }
// R1239
end_mp_subprogram_stmt ::= label? ((end (procedure identifier?)?) | (endprocedure identifier?)) { pin = 2}
// R1240
entry_stmt ::= entry identifier ('(' dummy_arg_list? ')' suffix? )? { pin = 1 }
// R1241
return_stmt ::= returnkwd (expr)? { pin = 1}
// R1242
contains_stmt ::= label? contains eol { pin = 2 }
// R1243
stmt_function_stmt ::= identifier '(' name_list ')' '=' expr { pin = 5 }

// That's a cap. Must be removed in the final version
cap ::= line_comment
